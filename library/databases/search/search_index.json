{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction to Databases Introduction All databases should have several characteristics in common: Error prevention Multitask environment Multiuser (exhaustive control) Backups (without stopping the environment) File based aproach In the past, files were used to store data. However, it lacks a lot of important characteristics that databases provide us. A multiuser environment is hard to implement. Using users in a machine is not the best option in practice. A multiuser environment allows us to have a security policy as well as sharing data among users/apps. Constraints are also hard to create and changes in the system required very drastic changes, which is not ideal. In order to palliate these problems, usually an application was developed, but it required constant development and management; and most of the responsibility was given to the developers. Concepts When talking about databases there are several important concepts that we should be familiarized with. Data distribution and access According to where the database can be accessed, several types can be found: Local Applications do not require data from other sites. Centralized Applications that require data from other sites Distributed Homogeneuos Has identical software and hardware running all database instances, and may appear through a single interface as if it were a single database. Heterogeneous They may have different hardware, operating systems, database management systems, and even data models for different databases. Data Model A data model explicitly determines the structure , manipulation and integrity aspects of the data stored in the data management systems (e.g. relational databases). There are several kinds of database models. Some of them are the flat model, the hierarchical model, the network model or the relational model. There are a lot of models and they are just put here to stimulate the curiosity of the reader. By contrast, we are going to see three possible perspective that were stated in a report in1975 by ANSI. In 1975, ANSI-SPARC declared 3 possible perspectives that conform the three level architecture . Its main objectives is to simplify the database management from the user by separating the main database from what the user actually sees, each one having a custom view of the data different from the other users and allowing the hardware to be changed without altering the user's view. External level This is the level that the user actually sees, showing the most important data for each user and excluding the data that is not as important as the others. Logical/Conceptual level This is the intermediate level, which describes the way parts of the database are connected and how they interact with each other and also describing which data is stored where. Physical/Internal level It is the lowest level, it describes the physical means by which the data are stored (partitions, CPUs, tablespaces, etc.). It might also include the discussion of compression and encryption techniques. DBMS The goal is to create and manage database elements from a software/manager . This software should be in charge of data manipulation , recovery routines , security and integrity constraints . A DBMS provides an extra layer of security, as it makes the access to the database impossible without it. So, if we were to try to access the database directly from a programming language (like accessing a file) we would fail. Some examples might be: protecting the money in a system failure of a banking system or making sure that the data is not lost or stolen in a reservation. Schema The database schema is its structure described in a formal language (the one supported by the DBMS). Integrity constraints are stated here. In a relational database a schema can define the tables, fields, relationships, etc. Schemas are usually stored in a data dictionary. DB users According to what/how the users require of the database there are several types. Application programmers Interact with the database by using DML queries in whatever programming language they are using. The queries are converted into object code which interacts with the database. Sophisticated users Database developers in charge of writing SQL queries to select/insert/delete/update data. They interact with the database directly with SQL and DBMS. Specializad users Sophisticated users in charge of writing special database application programs. Stand-alone users Use the database for personal use. Native users Use an application to interact with the database. They might even not be aware that they are using a database (or what is a database). DBA DBA or Database administrators are in charge of a lot of responsibilities. Some of them are installing/upgrading the DBMS servers, design and implement the databases,migrate or recover them and making sure that the security and performance are in good shape. Relational database A relational database is a database based on a relational model of data. They usually use SQL for querying and maintaining the database. In the relational model the data is organized into one or more tables. They have columns and rows with unique keys (used for identification). Each table usually represents one entity type and the rows represents an entity. Integrity Data integrity ensures overall completeness , accuracy and consistency of data. It is imposed by the means of error-checking methods and validation procedures that are usually discussed in the database design phase. There are several types of integrities according to what it concerns: entity, referential and domain integrity. All the data must be connected to other data and have the possibility of being traced. This allows that everything is recoverable and searchable. ACID vs BASE ACID and BASE are both sets of properties for database transactions. They are meant to ensure validity even if errors occur. ACID stands for Atomicity , Consistency , Isolation and Durability . Just like UNIX commands, an ACID transaction might be composed of several pieces but will be treated as a single one. If one piece fails/crashes, the entire transaction will become invalid, this phenomenon is called atomicity . Consistency will guarantee that the database is only in a valid state. In other words, prevents that the database gets corrupted by an illegal transaction. In order to achieve this, the database has to fulfill a set of defined rules. Due to concurrency, several transactions might be being processed at the moment. Isolation allows us to have some concurrency control and withdraw any effects from other transactions (have independence). Finally Durability assures that if a transaction was successfully committed, it will stay like that even if a crash is produced. On the other hand BASE stands for Basically Available , Soft state , Eventually consistent . Basically Available means that the system is available for querying by all users (no isolation is present). The database is only available \"most of the time\". A response will always be generated, but there is a possibility of it being a failure. The data is not immediately added to all nodes, it happens gradually, as it propagates across all nodes. This is called eventually consistent . Because of the \"eventual consistency model\" the values in the system might change (even when no transaction is made), and not all replicas are consistent, therefore the soft state . Despite ACID systems being the standard for most of database history, BASE systems may start to rise in use due to the amount of cost eventual consistency saves in comparison to having every transaction be checked individually. Metadata Metadata is \"data information that provides information about other data\u201d. Another way of thinking of metadata is as a short explanation or summary of what a data is. There are several types of metadata, which are: descriptive, structural, administrative, reference and statistical metadata. Descriptive metadata - describes information such as who made a file, where was it taken and how big the file is so it is used for discovery and identification Structural metadata - describes the structure of database objects such as tables, columns, keys and indexes - how the components of an object are organized Administrative metadata - information to help manage a resource, resource type, permissions Reference metadata - information about the contents and quality of statistical data. Statistical metadata - describe processes that collect, process, or produce statistical data For example, an image may include metadata that describes how large the picture is, the color depth, the image resolution and when the image was created. Author, date created, date modified and file size are examples of very basic document metadata. There are several uses of metadata: The most frequent application is the refinement of the queries on the search engines, because thanks to the additional information of metadata they are faster and more accurate so the user can avoid manual filters. Additionally, exists the problem that the user and the PC don't understand each other because the last one cannot interpret the meaning of data. Metadata can solve this explaining how related the data is. Finally, make data compression more efficient and the presentation of variable data, for instance, a video software can distinguish the first plane and the background and a mobile phone can recognize what is a person or not at the moment of taking a photograph. On-Line Transaction Processing (OLTP) It is a kind of system that is thoroughly used all over the world nowadays, and I dare say, is the most popular type of online systems (such as most of the web CRUD applications). Examples of such systems are ATMs, any type of online bank transaction, shopping on amazon, or even adding a book review on goodreads. OLTP is primarily backed by a database server that must meet a few crucial criteria. Transaction in the name stands for the fact that updates to the database need to be executed \"atomically\" which means that database must have consistent state to any user that will try to access it at a given point in time, thus the session is executed within a context of \"transaction\" between a user and a DB server. The criteria that DB must meet are most importantly: atomicity, concurrent access by many users at once, and integrity. Big concern of OLTP systems is concurrent access and its security, since DB should not be accessed by 2 users at the same time trying to modify the same data. Due to that fact, serious security checks need to be implemented. In a nutshell, OLTP is the idea that we all have in mind when whe think of a database. Data Warehousing A data warehouse is a system used for reporting and data analysis. Data Warehouses store current and historical data. The data may pass through a data cleasing and other operations which ensure data quality for reporting. In-memory databases An in-memory database relies on main memory for computer data storage. In-memory databases achieve much better speeds as accessing the memory is much faster than using a disk. These kinds of databases are used for applications where the response time is critical. In the past, this was totally unimaginable as the costs were very high. However, not everything is advantages, RAM is volatile, and in an event of a power loss, the data stored is lost.","title":"Introduction to Databases"},{"location":"#introduction-to-databases","text":"","title":"Introduction to Databases"},{"location":"#introduction","text":"All databases should have several characteristics in common: Error prevention Multitask environment Multiuser (exhaustive control) Backups (without stopping the environment)","title":"Introduction"},{"location":"#file-based-aproach","text":"In the past, files were used to store data. However, it lacks a lot of important characteristics that databases provide us. A multiuser environment is hard to implement. Using users in a machine is not the best option in practice. A multiuser environment allows us to have a security policy as well as sharing data among users/apps. Constraints are also hard to create and changes in the system required very drastic changes, which is not ideal. In order to palliate these problems, usually an application was developed, but it required constant development and management; and most of the responsibility was given to the developers.","title":"File based aproach"},{"location":"#concepts","text":"When talking about databases there are several important concepts that we should be familiarized with.","title":"Concepts"},{"location":"#data-distribution-and-access","text":"According to where the database can be accessed, several types can be found:","title":"Data distribution and access"},{"location":"#local","text":"Applications do not require data from other sites.","title":"Local"},{"location":"#centralized","text":"Applications that require data from other sites","title":"Centralized"},{"location":"#distributed","text":"","title":"Distributed"},{"location":"#homogeneuos","text":"Has identical software and hardware running all database instances, and may appear through a single interface as if it were a single database.","title":"Homogeneuos"},{"location":"#heterogeneous","text":"They may have different hardware, operating systems, database management systems, and even data models for different databases.","title":"Heterogeneous"},{"location":"#data-model","text":"A data model explicitly determines the structure , manipulation and integrity aspects of the data stored in the data management systems (e.g. relational databases). There are several kinds of database models. Some of them are the flat model, the hierarchical model, the network model or the relational model. There are a lot of models and they are just put here to stimulate the curiosity of the reader. By contrast, we are going to see three possible perspective that were stated in a report in1975 by ANSI. In 1975, ANSI-SPARC declared 3 possible perspectives that conform the three level architecture . Its main objectives is to simplify the database management from the user by separating the main database from what the user actually sees, each one having a custom view of the data different from the other users and allowing the hardware to be changed without altering the user's view.","title":"Data Model"},{"location":"#dbms","text":"The goal is to create and manage database elements from a software/manager . This software should be in charge of data manipulation , recovery routines , security and integrity constraints . A DBMS provides an extra layer of security, as it makes the access to the database impossible without it. So, if we were to try to access the database directly from a programming language (like accessing a file) we would fail. Some examples might be: protecting the money in a system failure of a banking system or making sure that the data is not lost or stolen in a reservation.","title":"DBMS"},{"location":"#schema","text":"The database schema is its structure described in a formal language (the one supported by the DBMS). Integrity constraints are stated here. In a relational database a schema can define the tables, fields, relationships, etc. Schemas are usually stored in a data dictionary.","title":"Schema"},{"location":"#db-users","text":"According to what/how the users require of the database there are several types.","title":"DB users"},{"location":"#application-programmers","text":"Interact with the database by using DML queries in whatever programming language they are using. The queries are converted into object code which interacts with the database.","title":"Application programmers"},{"location":"#sophisticated-users","text":"Database developers in charge of writing SQL queries to select/insert/delete/update data. They interact with the database directly with SQL and DBMS.","title":"Sophisticated users"},{"location":"#specializad-users","text":"Sophisticated users in charge of writing special database application programs.","title":"Specializad users"},{"location":"#stand-alone-users","text":"Use the database for personal use.","title":"Stand-alone users"},{"location":"#native-users","text":"Use an application to interact with the database. They might even not be aware that they are using a database (or what is a database).","title":"Native users"},{"location":"#dba","text":"DBA or Database administrators are in charge of a lot of responsibilities. Some of them are installing/upgrading the DBMS servers, design and implement the databases,migrate or recover them and making sure that the security and performance are in good shape.","title":"DBA"},{"location":"#relational-database","text":"A relational database is a database based on a relational model of data. They usually use SQL for querying and maintaining the database. In the relational model the data is organized into one or more tables. They have columns and rows with unique keys (used for identification). Each table usually represents one entity type and the rows represents an entity.","title":"Relational database"},{"location":"#integrity","text":"Data integrity ensures overall completeness , accuracy and consistency of data. It is imposed by the means of error-checking methods and validation procedures that are usually discussed in the database design phase. There are several types of integrities according to what it concerns: entity, referential and domain integrity. All the data must be connected to other data and have the possibility of being traced. This allows that everything is recoverable and searchable.","title":"Integrity"},{"location":"#acid-vs-base","text":"ACID and BASE are both sets of properties for database transactions. They are meant to ensure validity even if errors occur. ACID stands for Atomicity , Consistency , Isolation and Durability . Just like UNIX commands, an ACID transaction might be composed of several pieces but will be treated as a single one. If one piece fails/crashes, the entire transaction will become invalid, this phenomenon is called atomicity . Consistency will guarantee that the database is only in a valid state. In other words, prevents that the database gets corrupted by an illegal transaction. In order to achieve this, the database has to fulfill a set of defined rules. Due to concurrency, several transactions might be being processed at the moment. Isolation allows us to have some concurrency control and withdraw any effects from other transactions (have independence). Finally Durability assures that if a transaction was successfully committed, it will stay like that even if a crash is produced. On the other hand BASE stands for Basically Available , Soft state , Eventually consistent . Basically Available means that the system is available for querying by all users (no isolation is present). The database is only available \"most of the time\". A response will always be generated, but there is a possibility of it being a failure. The data is not immediately added to all nodes, it happens gradually, as it propagates across all nodes. This is called eventually consistent . Because of the \"eventual consistency model\" the values in the system might change (even when no transaction is made), and not all replicas are consistent, therefore the soft state . Despite ACID systems being the standard for most of database history, BASE systems may start to rise in use due to the amount of cost eventual consistency saves in comparison to having every transaction be checked individually.","title":"ACID vs BASE"},{"location":"#metadata","text":"Metadata is \"data information that provides information about other data\u201d. Another way of thinking of metadata is as a short explanation or summary of what a data is. There are several types of metadata, which are: descriptive, structural, administrative, reference and statistical metadata. Descriptive metadata - describes information such as who made a file, where was it taken and how big the file is so it is used for discovery and identification Structural metadata - describes the structure of database objects such as tables, columns, keys and indexes - how the components of an object are organized Administrative metadata - information to help manage a resource, resource type, permissions Reference metadata - information about the contents and quality of statistical data. Statistical metadata - describe processes that collect, process, or produce statistical data For example, an image may include metadata that describes how large the picture is, the color depth, the image resolution and when the image was created. Author, date created, date modified and file size are examples of very basic document metadata. There are several uses of metadata: The most frequent application is the refinement of the queries on the search engines, because thanks to the additional information of metadata they are faster and more accurate so the user can avoid manual filters. Additionally, exists the problem that the user and the PC don't understand each other because the last one cannot interpret the meaning of data. Metadata can solve this explaining how related the data is. Finally, make data compression more efficient and the presentation of variable data, for instance, a video software can distinguish the first plane and the background and a mobile phone can recognize what is a person or not at the moment of taking a photograph.","title":"Metadata"},{"location":"#on-line-transaction-processing-oltp","text":"It is a kind of system that is thoroughly used all over the world nowadays, and I dare say, is the most popular type of online systems (such as most of the web CRUD applications). Examples of such systems are ATMs, any type of online bank transaction, shopping on amazon, or even adding a book review on goodreads. OLTP is primarily backed by a database server that must meet a few crucial criteria. Transaction in the name stands for the fact that updates to the database need to be executed \"atomically\" which means that database must have consistent state to any user that will try to access it at a given point in time, thus the session is executed within a context of \"transaction\" between a user and a DB server. The criteria that DB must meet are most importantly: atomicity, concurrent access by many users at once, and integrity. Big concern of OLTP systems is concurrent access and its security, since DB should not be accessed by 2 users at the same time trying to modify the same data. Due to that fact, serious security checks need to be implemented. In a nutshell, OLTP is the idea that we all have in mind when whe think of a database.","title":"On-Line Transaction Processing (OLTP)"},{"location":"#data-warehousing","text":"A data warehouse is a system used for reporting and data analysis. Data Warehouses store current and historical data. The data may pass through a data cleasing and other operations which ensure data quality for reporting.","title":"Data Warehousing"},{"location":"#in-memory-databases","text":"An in-memory database relies on main memory for computer data storage. In-memory databases achieve much better speeds as accessing the memory is much faster than using a disk. These kinds of databases are used for applications where the response time is critical. In the past, this was totally unimaginable as the costs were very high. However, not everything is advantages, RAM is volatile, and in an event of a power loss, the data stored is lost.","title":"In-memory databases"},{"location":"SQL-Queries/","text":"SQL Queries DML Basic SQL sentences -- Full name of those customers belonging to the country identified by the id 52778. 2039 rows SELECT CUST_FIRST_NAME || ' ' || CUST_LAST_NAME AS NAME FROM CUSTOMERS WHERE COUNTRY_ID=52778; -- (INCORRECT?) Full name and descriptions of the products whose category is not 205 (the largest category). -- 50 rows. Notice that both attributes have the same content. SELECT DISTINCT PROD_NAME, PROD_DESC FROM PRODUCTS WHERE PROD_CATEGORY_ID <> 205; --> 53 ROWS -- AND PROD_NAME=PROD_DESC; (HAVE THE SAME CONENT? -> 44 ROWS) -- Full name of the customers having an email address in the server \"apple.com\". 1897 rows SELECT CUST_FIRST_NAME || ' ' || CUST_LAST_NAME AS NAME FROM CUSTOMERS WHERE CUST_EMAIL LIKE '%@apple.com'; -- Full name of those customers that have not provided their marital status. 17428 rows SELECT CUST_FIRST_NAME || ' ' || CUST_LAST_NAME AS NAME FROM CUSTOMERS WHERE cust_marital_status IS NULL; -- Write the query using the IS NULL operator and using = NULL. Do they have the same behavior? SELECT CUST_FIRST_NAME || ' ' || CUST_LAST_NAME AS NAME FROM CUSTOMERS WHERE cust_marital_status=NULL; -- -> 0 rows selected -- Show the sales of the product 45. Show the list chronologically ordered by date and also by the customer code (ascending). 10742 SELECT quantity_sold, amount_sold FROM SALES WHERE PROD_ID=45 ORDER BY time_id, cust_id ASC; -- Products in the category 205. Provide their names and the proportion between the catalog price and the minimum price -- (provide the data in percentage, with the % at the end to indicate it). 28 rows SELECT PROD_NAME, to_char((PROD_LIST_PRICE * 100)/PROD_MIN_PRICE) ||'%' AS PERCENTAGE FROM PRODUCTS WHERE prod_category_id=205; DML more SQL sentences -- (INCORRECTO?) List the information of all the sales made in the last century (we consider that the current century began on Jan 1st 2000). 427.256 rows SELECT PROD_ID, AMOUNT_SOLD FROM SALES WHERE TIME_ID > TO_DATE('2000-01-01', 'YYYY-MM-DD'); -- -> 492160 rows -- (INCORRECT?) Information of the costs that was stored in the database at most 18 years ago. 2173 rows SELECT PROD_ID, UNIT_COST, UNIT_PRICE FROM COSTS WHERE TIME_ID > ADD_MONTHS(SYSDATE, -(12*18)); -- -> 0 ROWS -- Get a list with the id of the customer and the id of the product sold and the date of the sale. Show the amount of three-years period spent from that day up to now. Name this column TRIENNIUM. 919.569 rows SELECT CUST_ID, PROD_ID, TIME_ID, TRUNC(MONTHS_BETWEEN(SYSDATE, TIME_ID)/(12*3)) Trienios FROM SALES; -- Show the name of all the products containing the (verbatim) tag \"Phone\". In the list, substitute such tag by \"Smartphone\". 9 rows SELECT PROD_NAME FROM PRODUCTS WHERE PROD_NAME LIKE '%Phone%'; -- Show the information of the customers (get the first and last name, ID and year of birth) living in the cities Aachen, Aalborg or Aalen. Those customers with no year of birth provided will appear with the label \"NON SUBMITTED\". Notice that the NVL function must have all its parameters of the same data_type. -- Can you simplify your query by using the property that these three cities begin with \"Aa\" (they are no more cities fulfilling this property). 175 rows SELECT CUST_FIRST_NAME, CUST_LAST_NAME, CUST_ID, NVL(TO_CHAR(CUST_YEAR_OF_BIRTH), 'NOT SUBMITTED') FROM CUSTOMERS WHERE CUST_CITY LIKE 'Aa%'; -- List the information of the sales made on the second Monday of each month. Provide the ID of the customer, ID of the product and date. Take into account that the DAY token in the TO_CHAR function for the dates can provides some extra spaces because it renders a fixed size output. 25181 SELECT CUST_ID, PROD_ID, TO_CHAR(TIME_ID, 'DD') FROM SALES WHERE TO_CHAR(TIME_ID, 'DD') BETWEEN 8 AND 14; -- Get a list of the customers that didn't submit their marital status. You have to inform about this situation and the name of the customer, following the schema: \"The customer ..........(full name of the customer) didn't provide .......(his or her) marital status. You can use the concat function (||) and also the DECODE function. The scape code for the symbol ' in Oracle is ''. 17428 rows SELECT CUST_FIRST_NAME || ' ' || CUST_LAST_NAME FROM CUSTOMERS WHERE CUST_MARITAL_STATUS IS NULL; DML Subqueries -- Name of the products where the difference between their cost and their price is more than 600 and such that it have been -- sold in a sale where the amount_sold value is greater than 1780. [V_SUBQ_1] SELECT DISTINCT PROD_NAME FROM PRODUCTS JOIN COSTS USING (PROD_ID) WHERE ABS(UNIT_COST - UNIT_PRICE) > 600 AND PROD_ID IN (SELECT DISTINCT PROD_ID FROM SALES WHERE AMOUNT_SOLD > 1780); -- (INCORRECT?) Full name and customer id of the customers from USA who bought some product listed in the above query and their salary is -- greater than 200.000. [V_SUBQ_2] SELECT DISTINCT CUST_ID, CUST_FIRST_NAME || ' ' || CUST_LAST_NAME FROM CUSTOMERS JOIN SALES SL USING (CUST_ID) WHERE PROD_ID IN ( SELECT DISTINCT PROD_ID FROM PRODUCTS JOIN COSTS USING (PROD_ID) WHERE ABS(UNIT_COST - UNIT_PRICE) > 600 AND PROD_ID IN (SELECT DISTINCT PROD_ID FROM SALES WHERE AMOUNT_SOLD > 1780)) AND (CUST_INCOME_LEVEL LIKE 'J%' OR CUST_INCOME_LEVEL LIKE 'K%' OR CUST_INCOME_LEVEL LIKE 'l%'); -- List the name of the products bought in USA on 1998 Christmas holidays. Notice that Christmas in USA coincides with the last -- two weeks of the year. [V_SUBQ_3] SELECT DISTINCT PROD_NAME FROM PRODUCTS WHERE PROD_ID IN (SELECT PROD_ID FROM SALES WHERE TIME_ID BETWEEN (SELECT date'1998-12-31' - 14 FROM DUAL) AND date'1999-01-01'); -- List the same information of the above query but translating it to Spain. In Spain, as you know, Christmas holidays also -- includes the first week of the next year. SELECT DISTINCT PROD_NAME FROM PRODUCTS WHERE PROD_ID IN (SELECT PROD_ID FROM SALES WHERE TIME_ID BETWEEN (SELECT date'1998-12-31' - 14 FROM DUAL) AND date'1998-12-31' + 7); -- How can you get all these sales in a single query? -- I don't understand, they should be already included in the last query. -- List the customer full name and yearof birth of the customers who have bought a product of the Hardware category SELECT DISTINCT CUST_FIRST_NAME || ' ' || CUST_LAST_NAME AS \"FULL NAME\", CUST_YEAR_OF_BIRTH FROM CUSTOMERS WHERE CUST_ID IN (SELECT CUST_ID FROM SALES JOIN PRODUCTS USING (PROD_ID) WHERE PROD_CATEGORY LIKE 'Hardware'); -- List the time ID of the sales where the customer was some of the previous customers. [V_SUBQ_7] SELECT DISTINCT TIME_ID FROM SALES WHERE CUST_ID IN (SELECT CUST_ID FROM (SELECT COUNT(TIME_ID) AS \"TIMES\", CUST_ID FROM SALES GROUP BY CUST_ID) WHERE TIMES > 1); -- Observe that in the previous query we are not searching the date of the product of the Hardware category sales, but the -- TIME ID of any sale of any of the customers in the previous exercise. Is there any difference? [V_SUBQ_8] SELECT DISTINCT TIME_ID FROM SALES JOIN PRODUCTS USING (PROD_ID) WHERE CUST_ID IN (SELECT CUST_ID FROM (SELECT COUNT(TIME_ID) AS \"TIMES\", CUST_ID FROM SALES GROUP BY CUST_ID) WHERE TIMES > 1) AND PROD_CATEGORY LIKE 'Hardware'; Aggregate Functions -- Calculate the number of customers stored in the database.V_AGGR_1 SELECT COUNT(CUST_ID) FROM CUSTOMERS; -- What is the total number of products?. Does it correspond with the highest ID_PRODUCTS or there exist some -- gap in the sequence?V_AGGR_2 SELECT COUNT(PROD_ID) FROM PRODUCTS; -- There are gaps in the sequence -- What is the number of different values for the marital status attribute?V_AGGR_3 SELECT COUNT(*) FROM (SELECT DISTINCT NVL(TO_CHAR(CUST_MARITAL_STATUS), 'NULLVALUE') FROM CUSTOMERS); -- Calculate the average of money that the customers spend.V_AGGR_4 SELECT ROUND(AVG(AMOUNT_SOLD), 2) AS \"AVERAGE MONEY SPENT\" FROM SALES; -- What is the average of the list price and the minimum price all the products?V_AGGR_5 SELECT ROUND(AVG(PROD_LIST_PRICE),2) AS \"AVERAGE LIST PRICE\", ROUND(AVG(PROD_MIN_PRICE), 2) AS \"AVERAGE MIN PRICE\" FROM PRODUCTS; -- What is the average, the maximum and the minimum of the list price of all the products?V_AGGR_6 SELECT ROUND(AVG(PROD_LIST_PRICE),2) AS \"AVERAGE LIST PRICE\", ROUND(MIN(PROD_LIST_PRICE),2) AS \"MINIMUM LIST PRICE\", ROUND(MAX(PROD_LIST_PRICE),2) AS \"MAXIMUM LIST PRICE\" FROM PRODUCTS; -- Compute the global amount of money earn by the company and the total number of single sales made during its lifetime.V_AGGR_7 Group Queries -- For each product, list its ID and the total amount of money earn with it. V_GR_1 SELECT PROD_ID, SUM(AMOUNT_SOLD) FROM SALES GROUP BY PROD_ID; -- For each country, list the number of its citizens and the ID of the country. V_GR_2 SELECT COUNTRY_ID, COUNT(DISTINCT CUST_ID) AS \"NUMBER OF CUSTOMERS\" FROM CUSTOMERS GROUP BY COUNTRY_ID; -- For each promotion, list its ID, the total number of sales corresponding with it, the number of different channels -- and the number of different customers that use the advantages of such promotion. V_GR_3 SELECT PROMO_ID, COUNT(QUANTITY_SOLD), COUNT(DISTINCT CHANNEL_ID), COUNT(DISTINCT CUST_ID) FROM SALES GROUP BY PROMO_ID; -- For each promotion and channel, compute the total amount of money received with its sales. V_GR_4 SELECT PROMO_ID, CHANNEL_ID, SUM(AMOUNT_SOLD) FROM SALES GROUP BY PROMO_ID, CHANNEL_ID; -- For each country and gender, calculate the number of customers in such category. Provide also the range of -- ages (minimum and maximum) for each category. V_GR_5 SELECT COUNTRY_ID, CUST_GENDER, COUNT(CUST_ID), MIN(CUST_YEAR_OF_BIRTH), MAX(CUST_YEAR_OF_BIRTH) FROM CUSTOMERS GROUP BY COUNTRY_ID, CUST_GENDER; -- For each continent, list the number of countries and the number of subcontinents. V_GR_6 SELECT COUNTRY_REGION, COUNT(COUNTRY_ID), COUNT(COUNTRY_SUBREGION) FROM COUNTRIES GROUP BY COUNTRY_REGION;","title":"SQL Queries"},{"location":"SQL-Queries/#sql-queries","text":"","title":"SQL Queries"},{"location":"SQL-Queries/#dml-basic-sql-sentences","text":"-- Full name of those customers belonging to the country identified by the id 52778. 2039 rows SELECT CUST_FIRST_NAME || ' ' || CUST_LAST_NAME AS NAME FROM CUSTOMERS WHERE COUNTRY_ID=52778; -- (INCORRECT?) Full name and descriptions of the products whose category is not 205 (the largest category). -- 50 rows. Notice that both attributes have the same content. SELECT DISTINCT PROD_NAME, PROD_DESC FROM PRODUCTS WHERE PROD_CATEGORY_ID <> 205; --> 53 ROWS -- AND PROD_NAME=PROD_DESC; (HAVE THE SAME CONENT? -> 44 ROWS) -- Full name of the customers having an email address in the server \"apple.com\". 1897 rows SELECT CUST_FIRST_NAME || ' ' || CUST_LAST_NAME AS NAME FROM CUSTOMERS WHERE CUST_EMAIL LIKE '%@apple.com'; -- Full name of those customers that have not provided their marital status. 17428 rows SELECT CUST_FIRST_NAME || ' ' || CUST_LAST_NAME AS NAME FROM CUSTOMERS WHERE cust_marital_status IS NULL; -- Write the query using the IS NULL operator and using = NULL. Do they have the same behavior? SELECT CUST_FIRST_NAME || ' ' || CUST_LAST_NAME AS NAME FROM CUSTOMERS WHERE cust_marital_status=NULL; -- -> 0 rows selected -- Show the sales of the product 45. Show the list chronologically ordered by date and also by the customer code (ascending). 10742 SELECT quantity_sold, amount_sold FROM SALES WHERE PROD_ID=45 ORDER BY time_id, cust_id ASC; -- Products in the category 205. Provide their names and the proportion between the catalog price and the minimum price -- (provide the data in percentage, with the % at the end to indicate it). 28 rows SELECT PROD_NAME, to_char((PROD_LIST_PRICE * 100)/PROD_MIN_PRICE) ||'%' AS PERCENTAGE FROM PRODUCTS WHERE prod_category_id=205;","title":"DML Basic SQL sentences"},{"location":"SQL-Queries/#dml-more-sql-sentences","text":"-- (INCORRECTO?) List the information of all the sales made in the last century (we consider that the current century began on Jan 1st 2000). 427.256 rows SELECT PROD_ID, AMOUNT_SOLD FROM SALES WHERE TIME_ID > TO_DATE('2000-01-01', 'YYYY-MM-DD'); -- -> 492160 rows -- (INCORRECT?) Information of the costs that was stored in the database at most 18 years ago. 2173 rows SELECT PROD_ID, UNIT_COST, UNIT_PRICE FROM COSTS WHERE TIME_ID > ADD_MONTHS(SYSDATE, -(12*18)); -- -> 0 ROWS -- Get a list with the id of the customer and the id of the product sold and the date of the sale. Show the amount of three-years period spent from that day up to now. Name this column TRIENNIUM. 919.569 rows SELECT CUST_ID, PROD_ID, TIME_ID, TRUNC(MONTHS_BETWEEN(SYSDATE, TIME_ID)/(12*3)) Trienios FROM SALES; -- Show the name of all the products containing the (verbatim) tag \"Phone\". In the list, substitute such tag by \"Smartphone\". 9 rows SELECT PROD_NAME FROM PRODUCTS WHERE PROD_NAME LIKE '%Phone%'; -- Show the information of the customers (get the first and last name, ID and year of birth) living in the cities Aachen, Aalborg or Aalen. Those customers with no year of birth provided will appear with the label \"NON SUBMITTED\". Notice that the NVL function must have all its parameters of the same data_type. -- Can you simplify your query by using the property that these three cities begin with \"Aa\" (they are no more cities fulfilling this property). 175 rows SELECT CUST_FIRST_NAME, CUST_LAST_NAME, CUST_ID, NVL(TO_CHAR(CUST_YEAR_OF_BIRTH), 'NOT SUBMITTED') FROM CUSTOMERS WHERE CUST_CITY LIKE 'Aa%'; -- List the information of the sales made on the second Monday of each month. Provide the ID of the customer, ID of the product and date. Take into account that the DAY token in the TO_CHAR function for the dates can provides some extra spaces because it renders a fixed size output. 25181 SELECT CUST_ID, PROD_ID, TO_CHAR(TIME_ID, 'DD') FROM SALES WHERE TO_CHAR(TIME_ID, 'DD') BETWEEN 8 AND 14; -- Get a list of the customers that didn't submit their marital status. You have to inform about this situation and the name of the customer, following the schema: \"The customer ..........(full name of the customer) didn't provide .......(his or her) marital status. You can use the concat function (||) and also the DECODE function. The scape code for the symbol ' in Oracle is ''. 17428 rows SELECT CUST_FIRST_NAME || ' ' || CUST_LAST_NAME FROM CUSTOMERS WHERE CUST_MARITAL_STATUS IS NULL;","title":"DML more SQL sentences"},{"location":"SQL-Queries/#dml-subqueries","text":"-- Name of the products where the difference between their cost and their price is more than 600 and such that it have been -- sold in a sale where the amount_sold value is greater than 1780. [V_SUBQ_1] SELECT DISTINCT PROD_NAME FROM PRODUCTS JOIN COSTS USING (PROD_ID) WHERE ABS(UNIT_COST - UNIT_PRICE) > 600 AND PROD_ID IN (SELECT DISTINCT PROD_ID FROM SALES WHERE AMOUNT_SOLD > 1780); -- (INCORRECT?) Full name and customer id of the customers from USA who bought some product listed in the above query and their salary is -- greater than 200.000. [V_SUBQ_2] SELECT DISTINCT CUST_ID, CUST_FIRST_NAME || ' ' || CUST_LAST_NAME FROM CUSTOMERS JOIN SALES SL USING (CUST_ID) WHERE PROD_ID IN ( SELECT DISTINCT PROD_ID FROM PRODUCTS JOIN COSTS USING (PROD_ID) WHERE ABS(UNIT_COST - UNIT_PRICE) > 600 AND PROD_ID IN (SELECT DISTINCT PROD_ID FROM SALES WHERE AMOUNT_SOLD > 1780)) AND (CUST_INCOME_LEVEL LIKE 'J%' OR CUST_INCOME_LEVEL LIKE 'K%' OR CUST_INCOME_LEVEL LIKE 'l%'); -- List the name of the products bought in USA on 1998 Christmas holidays. Notice that Christmas in USA coincides with the last -- two weeks of the year. [V_SUBQ_3] SELECT DISTINCT PROD_NAME FROM PRODUCTS WHERE PROD_ID IN (SELECT PROD_ID FROM SALES WHERE TIME_ID BETWEEN (SELECT date'1998-12-31' - 14 FROM DUAL) AND date'1999-01-01'); -- List the same information of the above query but translating it to Spain. In Spain, as you know, Christmas holidays also -- includes the first week of the next year. SELECT DISTINCT PROD_NAME FROM PRODUCTS WHERE PROD_ID IN (SELECT PROD_ID FROM SALES WHERE TIME_ID BETWEEN (SELECT date'1998-12-31' - 14 FROM DUAL) AND date'1998-12-31' + 7); -- How can you get all these sales in a single query? -- I don't understand, they should be already included in the last query. -- List the customer full name and yearof birth of the customers who have bought a product of the Hardware category SELECT DISTINCT CUST_FIRST_NAME || ' ' || CUST_LAST_NAME AS \"FULL NAME\", CUST_YEAR_OF_BIRTH FROM CUSTOMERS WHERE CUST_ID IN (SELECT CUST_ID FROM SALES JOIN PRODUCTS USING (PROD_ID) WHERE PROD_CATEGORY LIKE 'Hardware'); -- List the time ID of the sales where the customer was some of the previous customers. [V_SUBQ_7] SELECT DISTINCT TIME_ID FROM SALES WHERE CUST_ID IN (SELECT CUST_ID FROM (SELECT COUNT(TIME_ID) AS \"TIMES\", CUST_ID FROM SALES GROUP BY CUST_ID) WHERE TIMES > 1); -- Observe that in the previous query we are not searching the date of the product of the Hardware category sales, but the -- TIME ID of any sale of any of the customers in the previous exercise. Is there any difference? [V_SUBQ_8] SELECT DISTINCT TIME_ID FROM SALES JOIN PRODUCTS USING (PROD_ID) WHERE CUST_ID IN (SELECT CUST_ID FROM (SELECT COUNT(TIME_ID) AS \"TIMES\", CUST_ID FROM SALES GROUP BY CUST_ID) WHERE TIMES > 1) AND PROD_CATEGORY LIKE 'Hardware';","title":"DML Subqueries"},{"location":"SQL-Queries/#aggregate-functions","text":"-- Calculate the number of customers stored in the database.V_AGGR_1 SELECT COUNT(CUST_ID) FROM CUSTOMERS; -- What is the total number of products?. Does it correspond with the highest ID_PRODUCTS or there exist some -- gap in the sequence?V_AGGR_2 SELECT COUNT(PROD_ID) FROM PRODUCTS; -- There are gaps in the sequence -- What is the number of different values for the marital status attribute?V_AGGR_3 SELECT COUNT(*) FROM (SELECT DISTINCT NVL(TO_CHAR(CUST_MARITAL_STATUS), 'NULLVALUE') FROM CUSTOMERS); -- Calculate the average of money that the customers spend.V_AGGR_4 SELECT ROUND(AVG(AMOUNT_SOLD), 2) AS \"AVERAGE MONEY SPENT\" FROM SALES; -- What is the average of the list price and the minimum price all the products?V_AGGR_5 SELECT ROUND(AVG(PROD_LIST_PRICE),2) AS \"AVERAGE LIST PRICE\", ROUND(AVG(PROD_MIN_PRICE), 2) AS \"AVERAGE MIN PRICE\" FROM PRODUCTS; -- What is the average, the maximum and the minimum of the list price of all the products?V_AGGR_6 SELECT ROUND(AVG(PROD_LIST_PRICE),2) AS \"AVERAGE LIST PRICE\", ROUND(MIN(PROD_LIST_PRICE),2) AS \"MINIMUM LIST PRICE\", ROUND(MAX(PROD_LIST_PRICE),2) AS \"MAXIMUM LIST PRICE\" FROM PRODUCTS; -- Compute the global amount of money earn by the company and the total number of single sales made during its lifetime.V_AGGR_7","title":"Aggregate Functions"},{"location":"SQL-Queries/#group-queries","text":"-- For each product, list its ID and the total amount of money earn with it. V_GR_1 SELECT PROD_ID, SUM(AMOUNT_SOLD) FROM SALES GROUP BY PROD_ID; -- For each country, list the number of its citizens and the ID of the country. V_GR_2 SELECT COUNTRY_ID, COUNT(DISTINCT CUST_ID) AS \"NUMBER OF CUSTOMERS\" FROM CUSTOMERS GROUP BY COUNTRY_ID; -- For each promotion, list its ID, the total number of sales corresponding with it, the number of different channels -- and the number of different customers that use the advantages of such promotion. V_GR_3 SELECT PROMO_ID, COUNT(QUANTITY_SOLD), COUNT(DISTINCT CHANNEL_ID), COUNT(DISTINCT CUST_ID) FROM SALES GROUP BY PROMO_ID; -- For each promotion and channel, compute the total amount of money received with its sales. V_GR_4 SELECT PROMO_ID, CHANNEL_ID, SUM(AMOUNT_SOLD) FROM SALES GROUP BY PROMO_ID, CHANNEL_ID; -- For each country and gender, calculate the number of customers in such category. Provide also the range of -- ages (minimum and maximum) for each category. V_GR_5 SELECT COUNTRY_ID, CUST_GENDER, COUNT(CUST_ID), MIN(CUST_YEAR_OF_BIRTH), MAX(CUST_YEAR_OF_BIRTH) FROM CUSTOMERS GROUP BY COUNTRY_ID, CUST_GENDER; -- For each continent, list the number of countries and the number of subcontinents. V_GR_6 SELECT COUNTRY_REGION, COUNT(COUNTRY_ID), COUNT(COUNTRY_SUBREGION) FROM COUNTRIES GROUP BY COUNTRY_REGION;","title":"Group Queries"}]}