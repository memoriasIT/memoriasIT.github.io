{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introducci\u00f3n a la virtualizaci\u00f3n Disclaimer Estos apuntes fueron creados con el fin de estudio propio, sin embargo, para ayudar a los compa\u00f1eros y futuros internautas se encuentran aqu\u00ed. En diversos puntos de las notas se encuentran varias figuras, las cuales han sido recreadas de notas de la pizarra, de libros o de diapositivas dadas por el profesor. Espero que te sirva de apoyo para el estudio y motivaci\u00f3n para esta asignatura que he encontrado muy interesante. Introducci\u00f3n Com\u00fanmente se conoce como virtualizaci\u00f3n a la emulaci\u00f3n de sistemas operativos con programas como VMWare o Virtualbox. Sin embargo, la virtualizaci\u00f3n se encuentra mucho m\u00e1s presente, pues los procesos y threads son tambi\u00e9n ejemplos de virtualizaci\u00f3n de la CPU. De hecho, incluso los entornos de ventanas tambi\u00e9n se pueden considerar virtualizaci\u00f3n. A partir de ahora, solo se hablar\u00e1 de \"virtualizaci\u00f3n de m\u00e1quina\". \u00bfQu\u00e9 es una m\u00e1quina? Consideramos una m\u00e1quina a un Aut\u00f3mata con estados, que pasa de un estado a otro seg\u00fan una circustancia dada. Un computador no es m\u00e1s que una m\u00e1quina de estados. Un diagrama de estados con conjuntos de [0, 1] nos permitir\u00eda englobar todos los estados del ordenador. \u00bfQu\u00e9 es la virtualizaci\u00f3n? Nos permite ofrecer recursos hardware ficticios usando software/hardware. En su diagrama de estados de una m\u00e1quina virtual, es posible que encontremos estados no existentes en la m\u00e1quina real. Principio de equivalencia El software debe de ejecutarse del mismo modo en la m\u00e1quina virtual que en el hardware real, el usuario de la m\u00e1quina virtual no deber\u00eda de notar la diferencia con un hardware real. A pesar de que su comportamiento debe ser el mismo, se permite que el tiempo de ejecuci\u00f3n pueda no ser el mismo (en general suele ser m\u00e1s lento). El caso id\u00edlico de diagrama de estados debe de ser 1:1, pero en lo pr\u00e1ctico esto no se cumple. Esto se debe en parte a que la m\u00e1quina real puede ejecutar m\u00e1s cosas en paralelo (como varias m\u00e1quinas virtuales). Motivaciones Emulaci\u00f3n de m\u00e1quinas/sistemas operativos: la m\u00e1quina puede no existir o podemos no tener acceso a ellas. Ejecuci\u00f3n de legacy code : por problemas de compatibilidad. Experimentaci\u00f3n ( sandboxes , what-if?, etc.): por ejemplo para reversing de malware, o el propio chroot se puede considerar sandboxing. Isolation entre los guests (separaci\u00f3n de servicios en diferentes servidores virtuales) Consolidaci\u00f3n : ejecutar varias m\u00e1quinas f\u00edsicas, clonaci\u00f3n de m\u00e1quinas virtuales, facilita el balanceo de carga, infraestructuras a prueba de fallos (failover)... \u00bfCPU con esquema USER-SO-HW? En un CPU es necesario que existan dos modos para poder tener el esquema USER-SO-HW . Estos dos modos son usuario y kernel/superusuario. Esto puede conseguirse facilmente en hardware con un solo bit ( 0 - usuario, 1- kernel ). Para el cambio entre estos modos se realiza mediante el uso de Interrupciones. En teor\u00eda un SO no deber\u00eda de ejecutarse si no se ejecuta una interrupci\u00f3n. Un SO que se ejecuta en todo momento no es un SO bueno, pues resta tiempo de ejecuci\u00f3n al programa principal. Del usuario al SO se utilizan las system calls , del hardware pueden ser ejemplos el timer o la planificaci\u00f3n de los procesos. Terminolog\u00eda Hipervisor (o VMM = Virtual Machine Monitor) Es el propio software de virtualizaci\u00f3n en s\u00ed (a veces denominado emulador). Es el encargado de proporcionar la abstracci\u00f3n de una m\u00e1quina. Son muy parecidos a los sistemas operativos. Permite la compartici\u00f3n de CPU, de memoria entre m\u00e1quinas, posee control de permisos y arbitraje al acceso de perif\u00e9ricos, red, etc. A pesar de que sea una capa de software, puede estar asistida por el hardware. Este posee un control completo de los recursos del sistema f\u00edsico. Funciones Dispatcher : Se encarga de decidir que hacer tras una trap/interrupci\u00f3n. Allocator : Asigna los recursos f\u00edsicos (reales) a la m\u00e1quina virtual. Int\u00e9rprete : Simula las instrucciones que intercepta. M\u00e1quina Virtual (VM) Sigue modelo de Neumman, con recursos virtualizados: CPU, RAM, almacenamiento... Guest Es el sistema operativo instalado en la m\u00e1quina virtual Host Instalado sobre hardware f\u00edsico. En un modelo de servidor ESXi no existe un Host. Historia 1974 - Art\u00edculo de Popek y Goldberg Ya se introducen varios conceptos de m\u00e1quinas virtuales (VM) e hipervisores (VMM). Equivalencia : comportamiento id\u00e9ntico entre m\u00e1quinas (de nuevo, a excepci\u00f3n de los temporizadores). Control de recursos : El hipervisor posee todo el control de los recursos virtualizados. Eficiencia : La mayor\u00eda de las instrucciones deben de ejecutarse sin intervenci\u00f3n del hipervisor. Adem\u00e1s, se habla de varios tipos de funcionamiento (que ya exist\u00edan CPU desde los 60 que lo consegu\u00edan). Privilegiadas : generaban un trap en usuario y se ejecutaban en privilegiado. Sensitive instructions Control-sensitive : cambian la configuraci\u00f3n de recursos del sistema. Por ejemplo I/O o cambiar la tabla de vectores. Behaviour-sensitive : su comportamiento depende de la configuraci\u00f3n de recursos (modo supervisor/usuario). Inocuas : ej. suma Teorema 1: virtualizaci\u00f3n (estricta) Todas las instrucciones cr\u00edticas deben de ser cedidas al hipervisor mediante el uso de traps. Un ejemplo de instrucci\u00f3n cr\u00edtica que debe de ser ejecutada en forma privilegiada es HALT. Esta para la ejecuci\u00f3n del procesador hasta que sea despertada por una interrupci\u00f3n. Esta caracter\u00edstica debe de ser proporcionada por la CPU. Si no cumple esta caracter\u00edstica no son estr\u00edctamente virtualizables, sin embargo, mediante el uso de \"trucos\" se puede llegar a conseguir. Teorema 2: virtualizaci\u00f3n recursiva Una m\u00e1quina es virtualizable si cumple el teorema 1 y posee suficientes recursos. La virtualizaci\u00f3n recursiva no es siempre posible (virtualizar dentro de la m\u00e1quina virtualizada). Tipos de maquinas virtuales (T\u00e9cnicas de Virtualizaci\u00f3n) Tipo 1: Full Machine Virtualization El SO esta en una capa de abstracci\u00f3n independiente (totalmente desacoplado del HW) gracias al hipervisor. El SO no es consciente de que esta siendo virtualizado y no requiere de modificaciones. Hipervisores tipo 1 (Native/Bare Metal) El VMM se ejecuta sobre la propia m\u00e1quina f\u00edsica. Los SO estan bajo el control de VMM. Simula las operaciones de E/S directamente sobre sus propios drivers que controlan el hardware. Los threads que existen en las m\u00e1quinas virtuales son invisibles para el hipervisor. El hipervisor solo se encarga de servir estas llamadas sin saber que ocurre. Hipervisores tipo 2 (Hosted) El VMM es una aplicaci\u00f3n de un SO host, pero emula una m\u00e1quina virtual sobre el que se puede ejecutar un SO invitado. Esto se ejecuta en un proceso normal de un SO en modo usuario. Por tanto, es necesario que las instrucciones privilegiadas sean interceptadas por un m\u00f3dulo del n\u00facleo del SO. Simula las operaciones de E/S con servicios del SO real (por ejemplo ficheros). Algunos ejemplos podr\u00edan ser VMWare Workstation o VirtualBox. Tipo 2: Paravirtualizaci\u00f3n El VMM se ejecuta sobre el hardware (sin emular), como un SO, y ofrece interfaz con la m\u00e1quina real donde el SO invitado debe ser adaptado a dicho interfaz. Existe comunicaci\u00f3n expl\u00edcita entre el SO guest y el hipervisor, con el objetivo de ser m\u00e1s eficaz. Esta rapidez en parte se debe a eliminar las traps necesarias con las instrucciones cr\u00edticas. Se debe de modificar el kernel del SO guest, reemplazando las instrucciones no-virtualizables por hipercalls que comunican directamente con el hipervisor. El hipervisor tambi\u00e9n proporciona hipercalls para otras operaciones cr\u00edticas del kernel (tales como manejo de memoria, manejo de las interrupciones, informaci\u00f3n de reloj, etc.). Ejemplo de paravirtualizaci\u00f3n en la realidad: Proyecto Xen Tipo 3: Language Runtimes (como la m\u00e1quina virtual de Java) o los contenedores son ejemplos de esta categor\u00eda.","title":"Introducci\u00f3n a la virtualizaci\u00f3n"},{"location":"#introduccion-a-la-virtualizacion","text":"","title":"Introducci\u00f3n a la virtualizaci\u00f3n"},{"location":"#disclaimer","text":"Estos apuntes fueron creados con el fin de estudio propio, sin embargo, para ayudar a los compa\u00f1eros y futuros internautas se encuentran aqu\u00ed. En diversos puntos de las notas se encuentran varias figuras, las cuales han sido recreadas de notas de la pizarra, de libros o de diapositivas dadas por el profesor. Espero que te sirva de apoyo para el estudio y motivaci\u00f3n para esta asignatura que he encontrado muy interesante.","title":"Disclaimer"},{"location":"#introduccion","text":"Com\u00fanmente se conoce como virtualizaci\u00f3n a la emulaci\u00f3n de sistemas operativos con programas como VMWare o Virtualbox. Sin embargo, la virtualizaci\u00f3n se encuentra mucho m\u00e1s presente, pues los procesos y threads son tambi\u00e9n ejemplos de virtualizaci\u00f3n de la CPU. De hecho, incluso los entornos de ventanas tambi\u00e9n se pueden considerar virtualizaci\u00f3n. A partir de ahora, solo se hablar\u00e1 de \"virtualizaci\u00f3n de m\u00e1quina\".","title":"Introducci\u00f3n"},{"location":"#que-es-una-maquina","text":"Consideramos una m\u00e1quina a un Aut\u00f3mata con estados, que pasa de un estado a otro seg\u00fan una circustancia dada. Un computador no es m\u00e1s que una m\u00e1quina de estados. Un diagrama de estados con conjuntos de [0, 1] nos permitir\u00eda englobar todos los estados del ordenador.","title":"\u00bfQu\u00e9 es una m\u00e1quina?"},{"location":"#que-es-la-virtualizacion","text":"Nos permite ofrecer recursos hardware ficticios usando software/hardware. En su diagrama de estados de una m\u00e1quina virtual, es posible que encontremos estados no existentes en la m\u00e1quina real.","title":"\u00bfQu\u00e9 es la virtualizaci\u00f3n?"},{"location":"#principio-de-equivalencia","text":"El software debe de ejecutarse del mismo modo en la m\u00e1quina virtual que en el hardware real, el usuario de la m\u00e1quina virtual no deber\u00eda de notar la diferencia con un hardware real. A pesar de que su comportamiento debe ser el mismo, se permite que el tiempo de ejecuci\u00f3n pueda no ser el mismo (en general suele ser m\u00e1s lento). El caso id\u00edlico de diagrama de estados debe de ser 1:1, pero en lo pr\u00e1ctico esto no se cumple. Esto se debe en parte a que la m\u00e1quina real puede ejecutar m\u00e1s cosas en paralelo (como varias m\u00e1quinas virtuales).","title":"Principio de equivalencia"},{"location":"#motivaciones","text":"Emulaci\u00f3n de m\u00e1quinas/sistemas operativos: la m\u00e1quina puede no existir o podemos no tener acceso a ellas. Ejecuci\u00f3n de legacy code : por problemas de compatibilidad. Experimentaci\u00f3n ( sandboxes , what-if?, etc.): por ejemplo para reversing de malware, o el propio chroot se puede considerar sandboxing. Isolation entre los guests (separaci\u00f3n de servicios en diferentes servidores virtuales) Consolidaci\u00f3n : ejecutar varias m\u00e1quinas f\u00edsicas, clonaci\u00f3n de m\u00e1quinas virtuales, facilita el balanceo de carga, infraestructuras a prueba de fallos (failover)...","title":"Motivaciones"},{"location":"#cpu-con-esquema-user-so-hw","text":"En un CPU es necesario que existan dos modos para poder tener el esquema USER-SO-HW . Estos dos modos son usuario y kernel/superusuario. Esto puede conseguirse facilmente en hardware con un solo bit ( 0 - usuario, 1- kernel ). Para el cambio entre estos modos se realiza mediante el uso de Interrupciones. En teor\u00eda un SO no deber\u00eda de ejecutarse si no se ejecuta una interrupci\u00f3n. Un SO que se ejecuta en todo momento no es un SO bueno, pues resta tiempo de ejecuci\u00f3n al programa principal. Del usuario al SO se utilizan las system calls , del hardware pueden ser ejemplos el timer o la planificaci\u00f3n de los procesos.","title":"\u00bfCPU con esquema USER-SO-HW?"},{"location":"#terminologia","text":"","title":"Terminolog\u00eda"},{"location":"#hipervisor-o-vmm-virtual-machine-monitor","text":"Es el propio software de virtualizaci\u00f3n en s\u00ed (a veces denominado emulador). Es el encargado de proporcionar la abstracci\u00f3n de una m\u00e1quina. Son muy parecidos a los sistemas operativos. Permite la compartici\u00f3n de CPU, de memoria entre m\u00e1quinas, posee control de permisos y arbitraje al acceso de perif\u00e9ricos, red, etc. A pesar de que sea una capa de software, puede estar asistida por el hardware. Este posee un control completo de los recursos del sistema f\u00edsico.","title":"Hipervisor (o VMM = Virtual Machine Monitor)"},{"location":"#funciones","text":"Dispatcher : Se encarga de decidir que hacer tras una trap/interrupci\u00f3n. Allocator : Asigna los recursos f\u00edsicos (reales) a la m\u00e1quina virtual. Int\u00e9rprete : Simula las instrucciones que intercepta.","title":"Funciones"},{"location":"#maquina-virtual-vm","text":"Sigue modelo de Neumman, con recursos virtualizados: CPU, RAM, almacenamiento...","title":"M\u00e1quina Virtual (VM)"},{"location":"#guest","text":"Es el sistema operativo instalado en la m\u00e1quina virtual","title":"Guest"},{"location":"#host","text":"Instalado sobre hardware f\u00edsico. En un modelo de servidor ESXi no existe un Host.","title":"Host"},{"location":"#historia","text":"","title":"Historia"},{"location":"#1974-articulo-de-popek-y-goldberg","text":"Ya se introducen varios conceptos de m\u00e1quinas virtuales (VM) e hipervisores (VMM). Equivalencia : comportamiento id\u00e9ntico entre m\u00e1quinas (de nuevo, a excepci\u00f3n de los temporizadores). Control de recursos : El hipervisor posee todo el control de los recursos virtualizados. Eficiencia : La mayor\u00eda de las instrucciones deben de ejecutarse sin intervenci\u00f3n del hipervisor. Adem\u00e1s, se habla de varios tipos de funcionamiento (que ya exist\u00edan CPU desde los 60 que lo consegu\u00edan). Privilegiadas : generaban un trap en usuario y se ejecutaban en privilegiado. Sensitive instructions Control-sensitive : cambian la configuraci\u00f3n de recursos del sistema. Por ejemplo I/O o cambiar la tabla de vectores. Behaviour-sensitive : su comportamiento depende de la configuraci\u00f3n de recursos (modo supervisor/usuario). Inocuas : ej. suma","title":"1974 - Art\u00edculo de Popek y Goldberg"},{"location":"#teorema-1-virtualizacion-estricta","text":"Todas las instrucciones cr\u00edticas deben de ser cedidas al hipervisor mediante el uso de traps. Un ejemplo de instrucci\u00f3n cr\u00edtica que debe de ser ejecutada en forma privilegiada es HALT. Esta para la ejecuci\u00f3n del procesador hasta que sea despertada por una interrupci\u00f3n. Esta caracter\u00edstica debe de ser proporcionada por la CPU. Si no cumple esta caracter\u00edstica no son estr\u00edctamente virtualizables, sin embargo, mediante el uso de \"trucos\" se puede llegar a conseguir.","title":"Teorema 1: virtualizaci\u00f3n (estricta)"},{"location":"#teorema-2-virtualizacion-recursiva","text":"Una m\u00e1quina es virtualizable si cumple el teorema 1 y posee suficientes recursos. La virtualizaci\u00f3n recursiva no es siempre posible (virtualizar dentro de la m\u00e1quina virtualizada).","title":"Teorema 2: virtualizaci\u00f3n recursiva"},{"location":"#tipos-de-maquinas-virtuales-tecnicas-de-virtualizacion","text":"","title":"Tipos de maquinas virtuales (T\u00e9cnicas de Virtualizaci\u00f3n)"},{"location":"#tipo-1-full-machine-virtualization","text":"El SO esta en una capa de abstracci\u00f3n independiente (totalmente desacoplado del HW) gracias al hipervisor. El SO no es consciente de que esta siendo virtualizado y no requiere de modificaciones.","title":"Tipo 1: Full Machine Virtualization"},{"location":"#tipo-2-paravirtualizacion","text":"El VMM se ejecuta sobre el hardware (sin emular), como un SO, y ofrece interfaz con la m\u00e1quina real donde el SO invitado debe ser adaptado a dicho interfaz. Existe comunicaci\u00f3n expl\u00edcita entre el SO guest y el hipervisor, con el objetivo de ser m\u00e1s eficaz. Esta rapidez en parte se debe a eliminar las traps necesarias con las instrucciones cr\u00edticas. Se debe de modificar el kernel del SO guest, reemplazando las instrucciones no-virtualizables por hipercalls que comunican directamente con el hipervisor. El hipervisor tambi\u00e9n proporciona hipercalls para otras operaciones cr\u00edticas del kernel (tales como manejo de memoria, manejo de las interrupciones, informaci\u00f3n de reloj, etc.). Ejemplo de paravirtualizaci\u00f3n en la realidad: Proyecto Xen","title":"Tipo 2: Paravirtualizaci\u00f3n"},{"location":"#tipo-3","text":"Language Runtimes (como la m\u00e1quina virtual de Java) o los contenedores son ejemplos de esta categor\u00eda.","title":"Tipo 3:"},{"location":"T2/","text":"Virtualizaci\u00f3n de los recursos HW Implementaci\u00f3n de la CPU con el hipervisor Todas las implementaciones que se mencionan a continuaci\u00f3n son transparentes. Existen otras formas de conseguir virtualizaci\u00f3n, como puede ser la paravirtualizaci\u00f3n, pero no cumplen el hecho de ser transparentes pues se necesita el c\u00f3digo fuente. Emulaci\u00f3n (CPU real y virtual distintas) Un CPU es un sistema del cual conocemos su m\u00e1quina de estados (sabemos tal y como se comporta), por tanto sabemos como emularlo. Por ejemplo, podemos emular una CPU basada en RISC con una m\u00e1quina de intel. Quiz\u00e1s el tiempo de ejecuci\u00f3n puede ser peor, pero nos permite tener algo funcional (en el campo profesional es posible realizar emulaci\u00f3n a nivel de transistor). Virtualizaci\u00f3n nativa (CPU real y virtual id\u00e9nticas, o con el mismo conjunto de instrucciones) Es mejor caso que en la emulaci\u00f3n, pues es posible que no todas las instrucciones tengan que ser emuladas, sino que deber\u00edan de ser mapeadas. Traducci\u00f3n Binaria Se realiza la traducci\u00f3n en tiempo de ejecuci\u00f3n. Las instrucciones de la CPU se analizan y precompilan para traducirse a un c\u00f3digo que sea seguro para la CPU real sin instrucciones privilegiadas y que incluye c\u00f3digo de emulaci\u00f3n por software del hardware de E/S virtual. A pesar de que la traducci\u00f3n puede llevar cierto tiempo adicional, el c\u00f3digo traducido puede ejecutarse indefinidamente. Trap & Emulate Los principios son los mismos que en el paper de Popek y Goldberg. Se deja ejecutar a la CPU real el c\u00f3digo de la CPU virtual pero en modo no privilegiado. Cuando utiliza instrucciones privilegiadas, genera excepciones en la CPU real que debe emular por software. El modo privilegiado de la CPU virtual es emulado por software para que el kernel virtual no tenga privilegios sobre el hardware real. El sistema guest posee una tabla de interrupciones tal y como el sistema operativo host, pero no es \"real\", decimos que son estructuras \"shadow\". El sistema operativo host, conoce esta tabla pues cuando se quiere generar necesita de modo privilegiado, haciendo pues saber al hipervisor de esta estructura.de esta estructura. Es posible que no sea virtualizable en el sentido cl\u00e1sico (ej. Intel x86), pues puede tener efectos distintos entre el modo usuario y el supervisor., pues puede tener efectos distintos entre el modo usuario y el supervisor. Adem\u00e1s tantas traps producen mucho overhead. Y el hipervisor debe emular por software gran cantidad de estructuras shadow. Para intentar paliar este overhead, se crea un modo pseudo-supervisor que simula la CPU virtual en modo privilegiado pero sin privilegios sobre el hardware real. Runtime Binary Translation Se posee el c\u00f3digo binario, se localizan las instrucciones cr\u00edticas y se sustituyen por alguna rutina que el hipervisor controle. Un ejemplo puede ser la instrucci\u00f3n HALT. Este ser\u00eda cambiado por una rutina que se ejecutar\u00e1 en modo no privilegiado pero que simular\u00e1 el modo privilegiado de la CPU virtual. Esto no es siempre posible puesto que algunos c\u00f3digos que se auto-modifican o se auto-referencian (cargan datos de la zona de c\u00f3digo) hacen muy dificil su traducci\u00f3n. En general, esto no suele ser posible, pues es un gran problema para la seguridad. La traducci\u00f3n se produce al tener una interrupci\u00f3n, concretamente con las interrupciones de p\u00e1gina. Implementaci\u00f3n de los recursos hardware virtuales Virtualizaci\u00f3n de la CPU Se realiza una simulaci\u00f3n de la CPU virtual mediante t\u00e9cnicas software o soporte hardware. Es decir, con las t\u00e9cnicas vistas anteriormente. En todos los casos se debe simular un modo privilegiado para la MV y otro modo para el hipervisor. Para poder realizar esta virtualizaci\u00f3n es com\u00fan el uso de shadow registers . Estas son estructuras de control para ocultar los reales. Multiplexaci\u00f3n de la CPU entre MVs Puesto que muchos servidores est\u00e1n inactivos casi todo el tiempo, se realiza una planificaci\u00f3n de la CPU de tipo round-robin. Eso, con las m\u00e1quinas virtuales se traduce a: El S.O. invitado detiene la CPU cuando no est\u00e1 en uso. El hipervisor detecta la instrucci\u00f3n HALT y aprovecha para pasar el control a otra MV. Si una MV no bloquea la CPU en un lapso de tiempo, se producir\u00e1 una interrupci\u00f3n de su ejecuci\u00f3n para pasar el control a otra m\u00e1quina. Adem\u00e1s, el hipervisor puede tener pol\u00edticas para controlar el reparto del tiempo de CPU entre m\u00e1quinas virtuales. Esto puede generar tiempos de espera \"inexplicables\" cuando el hipervisor planifica otra m\u00e1quina virtual. Virtualizaci\u00f3n de la RAM ! TODO Diagrama 18 Para el manejo de la RAM la m\u00e1quina virtual debe de simular dos recursos hardware: el espacio f\u00edsico de memoria y la unidad de gestion de memoria (MMU) del procesador. Adem\u00e1s se debe de controlar el uso de la memoria f\u00edsica por parte de las m\u00e1quinas virtuales. Es decir, controlar el acceso (permisos, validez, presencia, swapping) y la traducci\u00f3n por p\u00e1ginas (se posee libertad para asignar memoria no continua a cada m\u00e1quina virtual y no asignar las p\u00e1ginas no usadas). Por tanto existiran dos MMUs: una para cada m\u00e1quina virtual y otra real en el hipervisor. Paginaci\u00f3n virtual Se pueden distinguir dos niveles de traducci\u00f3n. Dentro de la m\u00e1quina virtual: Del Espacio Logico Virtual (ELV) \u2192 Espacio Fisico Virtual (EFV) (S.O. Invitado) . En el hipervisor: Del Espacio Fisico Virtual (EFV) \u2192 Espacio Fisico REal (EFR) (Hipervisor) La MMU (Memory Management Unit) se puede implementar con simulacion por software o con soporte hardware. Simulaci\u00f3n Software (Shadow Page Tables) Las instrucciones que programan las MMU virtual son interceptadas y se programa la MMU f\u00edsica con la traducci\u00f3n directa ELV \u2192 EFR. Se requiere interceptar todo el acceso del S.O. invitado a la MMU emulada y guardar dos versiones de la TP (la del S.O. invitado, para su gestion, y la del hipervisor). Este segundo set esta oculto (shadow) para las MVs. Se deber\u00e1 detectar todo tipo de cambios, tales como modificaciones del PTBR (context switch), invalidaciones de la TLB, creaci\u00f3n de p\u00e1ginas, modificaciones de las TP, etc. Esto supone un overhead de memoria y proceso. Soporte Hardware (Nested paging/Extended page table) La MMU se encargar de traducir de ELV a EFV. Existe un segundo nivel de hardware de la MMU que traduce las referencias de EFV a EFR. El S.O. invitado programa las tablas del primer nivel. El hipervisor gestiona las tablas del segundo nivel de traducci\u00f3n. La TLB se encarga de hacer caching de la traducci\u00f3n final de ELV a EFR. Multiplexaci\u00f3n e la RAM del hipervisor entre MVs Debido a la localidad, muchos sistemas solo acceden a una parte de su memorias RAM durante un periodo de tiempo. El hipervisor controla la memoria en uso (accedida) dentro de cada m\u00e1quina. Inicialmente la m\u00e1quina va creciendo conforme usa su memoria RAM de sus bancos de RAM (asignaci\u00f3n bajo demanda). El hipervisor controla qu\u00e9 memoria continua us\u00e1ndose al cabo de un rato dentro de la MV (\"working set\" de la MV). Es por ello que la suma de la RAM en uso de todas las MVs puede exceder la RAM del sistema f\u00edsico (overcommiting). Si se agotara la RAM libre del hipervisor se puede liberar memoria no usada de una m\u00e1quina para concederla a otra. El contenido de una p\u00e1gina ya en uso se guarda en un fichero swap privado para cada MV. El swap del hipervisor es invisible al S.O. invitado (puesto que sigue creyendo que sus p\u00e1ginas estan en RAM). El hipervisor tambien permite definir pol\u00edticas para controlar el reparto de la RAM entre m\u00e1quinas virtuales. Virtualizaci\u00f3n de Discos La unidad de simulacion es el volumen virtual de disco (SCSI LUN). El volumen es un conjunto de bloques de tama\u00f1o uniforme (direccionamiento LBA). Cada volumen virtual se puede implementar de forma transparente ya sea sobre un volumen f\u00edsico real (by-pass) o con un fichero en un sistema de ficheros del hipervisor. En todos los casos se ofrece el mismo modelo de controlador al sistema virtual: * Independencia de la implementaci\u00f3n * El mismo driver en el S.O. virtual para todas las implementaciones Rendimiento de los discos Como es de esperar, en los vol\u00famenes f\u00edsicos (con by-pass) existe menos retardo adicional en las operaciones de acceso, as\u00ed como una menor portabilidad (pues necesitan un volumen real). Esto provoca que sea usado para aplicaciones cr\u00edticas o para migrar MV existentes. En los discos virtuales implementados sobre ficheros existe mayor latencia pero permite una gran portabiliad y flexibilidad. Pues es posible mover la ubicacion del volumen a un nuevo almacenamiento sin ni siquiera modificar la MV. Es posible no asignar el espacio libre del vol\u00famen, lo que supone una ventaja y riesgo al mismo tiempo. Puede provocar una fragmentaci\u00f3n e inanici\u00f3n por falta de disco real. Snapshots Son estados \"congelados\" de un sistema inform\u00e1tico y preservados en el tiepo para permitir una \"vuelta atr\u00e1s\" desde un estado posterior del sistema. Es osible congelar dispositvios de almacenamiento o la m\u00e1quina virtual completa (checkpoint). Snapshots de disco Permtie preservar el estaod de un dsico virtual en un punto del tiempo. Se puede implentar bloqueando el acceso de escritura al disco (solo permitiendo lecturas). Se crea otro \"volumen de snapshot\" vac\u00edo qeu solo guarda los bloques modificados. En este si se permite la lectura y escritura. Por tanto se realizan escrituras en el \"volumen de snapshot\" y las lecturas primero en el \"volumen de snapshot\" y si no se encuentra el bloque se lee del volumen original. Esto disminuye la eficiencia pues es necesario gestionar la asignaci\u00f3n de espacio para las modificiaciones, as\u00ed como consultar el \u00edndice de bloques modificados que contiene el snapshot Esto disminuye la eficiencia pues es necesario gestionar la asignaci\u00f3n de espacio para las modificiaciones, as\u00ed como consultar el \u00edndice de bloques modificados que contiene el snapshot. Snapshots de una MV Recuerda el estado de una m\u00e1quina completa (es decir, sus discos, contenido en RAM, configuraci\u00f3n hardware, etc.). Permite recuperar desastres de forma instantanea, pues permite volver instant\u00e1neamente a un estado estable. Se implementa guardando el estado de la RAM si est\u00e1 encendida y guardando un snapshot de disco. Eliminaci\u00f3n de Snapshots Existen dos modos de eliminar snapshots: Deshacer (rollback): se vuelve al estado anterior. Es r\u00e1pido. Se carga el estado de RAM guardado como RAM actual de la MV. Se elimina el archivo de snapshot y se reanuda el acceso en escritura al disco original. Consolidar (commit): se continua en el estado actual pero funcionando sin el snapshot, se elimina el estado de RAM guardado y se graban los bloques modificados sobre el disco original, finalmente se elimina el fichero de snapshot. El tiempo necesario depende de la cantidad de informaci\u00f3n a consolidar. Clones Son copias de m\u00e1quinas virtuales ya existentes. Ahorran el tiempo de instalaci\u00f3n y configuran una nueva instancia de un S.O. Los prototipos se pueden \"bloquear\" para convertirlos en m\u00e1quinas prefabricadas con un estado conocido del cual partir: el concepto se suele denominar comercialmente \"plantilla\". Full clones Copia convencional de una m\u00e1quina virtual. Se crea un nuevo disco virtual mediante una copia completa del original. Linked Clones Es una m\u00e1quina cuyo estado est\u00e1 almacenado mediante t\u00e9cnicas \"diferenciales\". Es decir, se guardan solo los cambios respecto a la plantilla. Se crea un nuevo disco virtual mediante un \"snapshot\" del disco de la plantilla. El snapshot solo almacena las escrituras o modificacines que realiza la m\u00e1quina \"clon\" durante su ejecuci\u00f3n. Ventajas y Desventajas La creaci\u00f3n de clones es casi instant\u00e1nea al no copiar el almacenamiento. Reduce espacio de dsico ocupado por cada nueva m\u00e1quina. Mejora la concurrencia de E/S a disco si el hipervisor implementa una cache de disco par alos bloques de los discos virtuales: * Reuso de las lecturas f\u00edsicas entre m\u00e1quinas virtuales. * Aumenta el hit-ratio de la cach\u00e9 de disco del hipervisor al acceder al mismo bloque en varias m\u00e1quinas. Si varios clones arrancan a la vez, el uso de disco no se multiplica por el n\u00famero de m\u00e1quinas virtuales. No se puede actualizar la plantilla ya que habr\u00eda que destruir los clones. Uso de los linked-clones Son muy \u00fatiles para escritorios virtuales. Puesto que existen numerosas instancias id\u00e9nticas a partir de una misma plantilla. Adem\u00e1s la vida de una m\u00e1quina virtual es breve (horas/d\u00edas). Los clones se destruyen cuando el usuario sale de la sesi\u00f3n. En cada nueva sesi\u00f3n se usa una m\u00e1quina virtual reci\u00e9n clonada. Para poder llevar esto a cabo se necesita una infraestructura de software (broker de MVs) que genere los clones bajo demanda. Virtualizaci\u00f3n de la red Es necesario simular una o m\u00e1s interfaces de red (NIC) en cada m\u00e1quina virtual y una o m\u00e1s LANs virtuales (switches Ethernet) simulando el trasporte de los paquetes; bien entre m\u00e1quinas virtuales o entre la LAN real y las LANs virtuales con los NICs reales del sistema host. NICs virtuales Cada NIC simula una interfaz de red con su propia MAC \u00fanica. Para cada NIC virtual el administrador especifica a qu\u00e9 LAN virtual se conecta. Se simula el interfaz de control (mediante registros de control y estado) de NICs populares para que el sistema operativo pueda usar drivers est\u00e1ndar. Algunos hipervisores simulan NICs virtuales optimizadas para rendimiento en una MV, pero requieren de drivers especiales. LANs Virtuales en desktops El hipervisor se encarga de simular 1 o m\u00e1s LANs virtuales. Cada LAN virtual puede estar asociada a un NIC real del host de diversas formas: Bridged: el NIC funciona como un bridge Ethernet (nivel 2) entre la LAN virtual y la LAN externa. NAT: se interpone un router IP con NAT entre la LAN virtual y la LAN externa usando como direcci\u00f3n la IP del host real. Las MVs tienen visibilidad a nivel IP de la LAN externa con las limitaciones inherentes de la NAT. Host-Only: La LAN no est\u00e1 asociada a ning\u00fan NIC (se encuentra aislada del exterior). Se utiliza para comunicar MVs entre si. LANs virtuales en servidores Se simulan uno o m\u00e1s switches virtuales Ethernet. Un vSwitch tiene asociados a su vez 0 o m\u00e1s NICs reales. Si tiene 0 se encuentra aislado del exterior. Si posee m\u00e1s de 1 se pueden usar pol\u00edticas de balanceo de carga o de fail-over. Cada NIC real aparenta un enlace Ethernet punto a punto entre el switch virtual y un switch externo. Dentro de cada vSwitch se definen 1 o m\u00e1s VLANs (grupos de puertos). Una MV puede tener 1 o m\u00e1s NICs virtuales conectadas a distintos grupos de puertos. A cada grupo de puertos se le asocia un tag de VLAN 802.1q. Los NICs reales multiplexan el enlace trabajando en modo trunk 802.1q (identificando la VLAN o grupos de cada paquete mediante el identificador o tag 802.1q en la cabecera del pquete). Los switches externos deben soportar tambi\u00e9n la multiplexaci\u00f3n IEEE802.1q en los puertos a los que est\u00e1n conectados los NICs reales del hipervisor. Implementaci\u00f3n de las LANs El paso de paquetes Ethernet entre NICs de m\u00e1quinas virtuales conectadas al mismo switch virtual se hace mediante buffers de memoria del hipervisor. Esto permite que la velocidad de paso de datos sea muy elevada. Las comunicaciones con el switch exterior se hacen compartiendo el NIC exterior. Cada MV usa su propia MAC para emitir. La recepci\u00f3n se hace en modo promiscuo. Los paquetes recibidos se entregan a NIC con la MAC correspondiente. Avances en el soporte de virtualizaci\u00f3n de las CPUs El soporte b\u00e1sico ayuda con la simulaci\u00f3n del comportamiento y registros de la CPU de la MV en modo pseudo-supervisor. La traducci\u00f3n de la MMU se puede hacer programando h\u00e1bilmente el hardware de paginaci\u00f3n, pero existen problemas de seguridad. Las CPUs actuales tambi\u00e9n aportan un modo virtual para que el hardware de paginaci\u00f3n que no posee permisos pueda acceder fuera de la memoria de la MV. El acceso a los dispotivios PCI se hace interceptando las instrucciones de acceso a los registros de control (IN/OUT). Algunas CPUs recientes incorporan dispositivos PCI virtuales que pueden ser simulaci\u00f3n por software o bien una acceso controlado a un dispositivo PCI verdadero.","title":"Virtualizaci\u00f3n de los recursos HW"},{"location":"T2/#virtualizacion-de-los-recursos-hw","text":"","title":"Virtualizaci\u00f3n de los recursos HW"},{"location":"T2/#implementacion-de-la-cpu-con-el-hipervisor","text":"Todas las implementaciones que se mencionan a continuaci\u00f3n son transparentes. Existen otras formas de conseguir virtualizaci\u00f3n, como puede ser la paravirtualizaci\u00f3n, pero no cumplen el hecho de ser transparentes pues se necesita el c\u00f3digo fuente.","title":"Implementaci\u00f3n de la CPU con el hipervisor"},{"location":"T2/#emulacion-cpu-real-y-virtual-distintas","text":"Un CPU es un sistema del cual conocemos su m\u00e1quina de estados (sabemos tal y como se comporta), por tanto sabemos como emularlo. Por ejemplo, podemos emular una CPU basada en RISC con una m\u00e1quina de intel. Quiz\u00e1s el tiempo de ejecuci\u00f3n puede ser peor, pero nos permite tener algo funcional (en el campo profesional es posible realizar emulaci\u00f3n a nivel de transistor).","title":"Emulaci\u00f3n (CPU real y virtual distintas)"},{"location":"T2/#virtualizacion-nativa-cpu-real-y-virtual-identicas-o-con-el-mismo-conjunto-de-instrucciones","text":"Es mejor caso que en la emulaci\u00f3n, pues es posible que no todas las instrucciones tengan que ser emuladas, sino que deber\u00edan de ser mapeadas.","title":"Virtualizaci\u00f3n nativa (CPU real y virtual id\u00e9nticas, o con el mismo conjunto de instrucciones)"},{"location":"T2/#traduccion-binaria","text":"Se realiza la traducci\u00f3n en tiempo de ejecuci\u00f3n. Las instrucciones de la CPU se analizan y precompilan para traducirse a un c\u00f3digo que sea seguro para la CPU real sin instrucciones privilegiadas y que incluye c\u00f3digo de emulaci\u00f3n por software del hardware de E/S virtual. A pesar de que la traducci\u00f3n puede llevar cierto tiempo adicional, el c\u00f3digo traducido puede ejecutarse indefinidamente.","title":"Traducci\u00f3n Binaria"},{"location":"T2/#implementacion-de-los-recursos-hardware-virtuales","text":"","title":"Implementaci\u00f3n de los recursos hardware virtuales"},{"location":"T2/#virtualizacion-de-la-cpu","text":"Se realiza una simulaci\u00f3n de la CPU virtual mediante t\u00e9cnicas software o soporte hardware. Es decir, con las t\u00e9cnicas vistas anteriormente. En todos los casos se debe simular un modo privilegiado para la MV y otro modo para el hipervisor. Para poder realizar esta virtualizaci\u00f3n es com\u00fan el uso de shadow registers . Estas son estructuras de control para ocultar los reales.","title":"Virtualizaci\u00f3n de la CPU"},{"location":"T2/#multiplexacion-de-la-cpu-entre-mvs","text":"Puesto que muchos servidores est\u00e1n inactivos casi todo el tiempo, se realiza una planificaci\u00f3n de la CPU de tipo round-robin. Eso, con las m\u00e1quinas virtuales se traduce a: El S.O. invitado detiene la CPU cuando no est\u00e1 en uso. El hipervisor detecta la instrucci\u00f3n HALT y aprovecha para pasar el control a otra MV. Si una MV no bloquea la CPU en un lapso de tiempo, se producir\u00e1 una interrupci\u00f3n de su ejecuci\u00f3n para pasar el control a otra m\u00e1quina. Adem\u00e1s, el hipervisor puede tener pol\u00edticas para controlar el reparto del tiempo de CPU entre m\u00e1quinas virtuales. Esto puede generar tiempos de espera \"inexplicables\" cuando el hipervisor planifica otra m\u00e1quina virtual.","title":"Multiplexaci\u00f3n de la CPU entre MVs"},{"location":"T2/#virtualizacion-de-la-ram","text":"! TODO Diagrama 18 Para el manejo de la RAM la m\u00e1quina virtual debe de simular dos recursos hardware: el espacio f\u00edsico de memoria y la unidad de gestion de memoria (MMU) del procesador. Adem\u00e1s se debe de controlar el uso de la memoria f\u00edsica por parte de las m\u00e1quinas virtuales. Es decir, controlar el acceso (permisos, validez, presencia, swapping) y la traducci\u00f3n por p\u00e1ginas (se posee libertad para asignar memoria no continua a cada m\u00e1quina virtual y no asignar las p\u00e1ginas no usadas). Por tanto existiran dos MMUs: una para cada m\u00e1quina virtual y otra real en el hipervisor.","title":"Virtualizaci\u00f3n de la RAM"},{"location":"T2/#paginacion-virtual","text":"Se pueden distinguir dos niveles de traducci\u00f3n. Dentro de la m\u00e1quina virtual: Del Espacio Logico Virtual (ELV) \u2192 Espacio Fisico Virtual (EFV) (S.O. Invitado) . En el hipervisor: Del Espacio Fisico Virtual (EFV) \u2192 Espacio Fisico REal (EFR) (Hipervisor) La MMU (Memory Management Unit) se puede implementar con simulacion por software o con soporte hardware.","title":"Paginaci\u00f3n virtual"},{"location":"T2/#simulacion-software-shadow-page-tables","text":"Las instrucciones que programan las MMU virtual son interceptadas y se programa la MMU f\u00edsica con la traducci\u00f3n directa ELV \u2192 EFR. Se requiere interceptar todo el acceso del S.O. invitado a la MMU emulada y guardar dos versiones de la TP (la del S.O. invitado, para su gestion, y la del hipervisor). Este segundo set esta oculto (shadow) para las MVs. Se deber\u00e1 detectar todo tipo de cambios, tales como modificaciones del PTBR (context switch), invalidaciones de la TLB, creaci\u00f3n de p\u00e1ginas, modificaciones de las TP, etc. Esto supone un overhead de memoria y proceso.","title":"Simulaci\u00f3n Software (Shadow Page Tables)"},{"location":"T2/#soporte-hardware-nested-pagingextended-page-table","text":"La MMU se encargar de traducir de ELV a EFV. Existe un segundo nivel de hardware de la MMU que traduce las referencias de EFV a EFR. El S.O. invitado programa las tablas del primer nivel. El hipervisor gestiona las tablas del segundo nivel de traducci\u00f3n. La TLB se encarga de hacer caching de la traducci\u00f3n final de ELV a EFR.","title":"Soporte Hardware (Nested paging/Extended page table)"},{"location":"T2/#multiplexacion-e-la-ram-del-hipervisor-entre-mvs","text":"Debido a la localidad, muchos sistemas solo acceden a una parte de su memorias RAM durante un periodo de tiempo. El hipervisor controla la memoria en uso (accedida) dentro de cada m\u00e1quina. Inicialmente la m\u00e1quina va creciendo conforme usa su memoria RAM de sus bancos de RAM (asignaci\u00f3n bajo demanda). El hipervisor controla qu\u00e9 memoria continua us\u00e1ndose al cabo de un rato dentro de la MV (\"working set\" de la MV). Es por ello que la suma de la RAM en uso de todas las MVs puede exceder la RAM del sistema f\u00edsico (overcommiting). Si se agotara la RAM libre del hipervisor se puede liberar memoria no usada de una m\u00e1quina para concederla a otra. El contenido de una p\u00e1gina ya en uso se guarda en un fichero swap privado para cada MV. El swap del hipervisor es invisible al S.O. invitado (puesto que sigue creyendo que sus p\u00e1ginas estan en RAM). El hipervisor tambien permite definir pol\u00edticas para controlar el reparto de la RAM entre m\u00e1quinas virtuales.","title":"Multiplexaci\u00f3n e la RAM del hipervisor entre MVs"},{"location":"T2/#virtualizacion-de-discos","text":"La unidad de simulacion es el volumen virtual de disco (SCSI LUN). El volumen es un conjunto de bloques de tama\u00f1o uniforme (direccionamiento LBA). Cada volumen virtual se puede implementar de forma transparente ya sea sobre un volumen f\u00edsico real (by-pass) o con un fichero en un sistema de ficheros del hipervisor. En todos los casos se ofrece el mismo modelo de controlador al sistema virtual: * Independencia de la implementaci\u00f3n * El mismo driver en el S.O. virtual para todas las implementaciones","title":"Virtualizaci\u00f3n de Discos"},{"location":"T2/#rendimiento-de-los-discos","text":"Como es de esperar, en los vol\u00famenes f\u00edsicos (con by-pass) existe menos retardo adicional en las operaciones de acceso, as\u00ed como una menor portabilidad (pues necesitan un volumen real). Esto provoca que sea usado para aplicaciones cr\u00edticas o para migrar MV existentes. En los discos virtuales implementados sobre ficheros existe mayor latencia pero permite una gran portabiliad y flexibilidad. Pues es posible mover la ubicacion del volumen a un nuevo almacenamiento sin ni siquiera modificar la MV. Es posible no asignar el espacio libre del vol\u00famen, lo que supone una ventaja y riesgo al mismo tiempo. Puede provocar una fragmentaci\u00f3n e inanici\u00f3n por falta de disco real.","title":"Rendimiento de los discos"},{"location":"T2/#snapshots","text":"Son estados \"congelados\" de un sistema inform\u00e1tico y preservados en el tiepo para permitir una \"vuelta atr\u00e1s\" desde un estado posterior del sistema. Es osible congelar dispositvios de almacenamiento o la m\u00e1quina virtual completa (checkpoint).","title":"Snapshots"},{"location":"T2/#snapshots-de-disco","text":"Permtie preservar el estaod de un dsico virtual en un punto del tiempo. Se puede implentar bloqueando el acceso de escritura al disco (solo permitiendo lecturas). Se crea otro \"volumen de snapshot\" vac\u00edo qeu solo guarda los bloques modificados. En este si se permite la lectura y escritura. Por tanto se realizan escrituras en el \"volumen de snapshot\" y las lecturas primero en el \"volumen de snapshot\" y si no se encuentra el bloque se lee del volumen original. Esto disminuye la eficiencia pues es necesario gestionar la asignaci\u00f3n de espacio para las modificiaciones, as\u00ed como consultar el \u00edndice de bloques modificados que contiene el snapshot Esto disminuye la eficiencia pues es necesario gestionar la asignaci\u00f3n de espacio para las modificiaciones, as\u00ed como consultar el \u00edndice de bloques modificados que contiene el snapshot.","title":"Snapshots de disco"},{"location":"T2/#snapshots-de-una-mv","text":"Recuerda el estado de una m\u00e1quina completa (es decir, sus discos, contenido en RAM, configuraci\u00f3n hardware, etc.). Permite recuperar desastres de forma instantanea, pues permite volver instant\u00e1neamente a un estado estable. Se implementa guardando el estado de la RAM si est\u00e1 encendida y guardando un snapshot de disco.","title":"Snapshots de una MV"},{"location":"T2/#eliminacion-de-snapshots","text":"Existen dos modos de eliminar snapshots: Deshacer (rollback): se vuelve al estado anterior. Es r\u00e1pido. Se carga el estado de RAM guardado como RAM actual de la MV. Se elimina el archivo de snapshot y se reanuda el acceso en escritura al disco original. Consolidar (commit): se continua en el estado actual pero funcionando sin el snapshot, se elimina el estado de RAM guardado y se graban los bloques modificados sobre el disco original, finalmente se elimina el fichero de snapshot. El tiempo necesario depende de la cantidad de informaci\u00f3n a consolidar.","title":"Eliminaci\u00f3n de Snapshots"},{"location":"T2/#clones","text":"Son copias de m\u00e1quinas virtuales ya existentes. Ahorran el tiempo de instalaci\u00f3n y configuran una nueva instancia de un S.O. Los prototipos se pueden \"bloquear\" para convertirlos en m\u00e1quinas prefabricadas con un estado conocido del cual partir: el concepto se suele denominar comercialmente \"plantilla\".","title":"Clones"},{"location":"T2/#full-clones","text":"Copia convencional de una m\u00e1quina virtual. Se crea un nuevo disco virtual mediante una copia completa del original.","title":"Full clones"},{"location":"T2/#linked-clones","text":"Es una m\u00e1quina cuyo estado est\u00e1 almacenado mediante t\u00e9cnicas \"diferenciales\". Es decir, se guardan solo los cambios respecto a la plantilla. Se crea un nuevo disco virtual mediante un \"snapshot\" del disco de la plantilla. El snapshot solo almacena las escrituras o modificacines que realiza la m\u00e1quina \"clon\" durante su ejecuci\u00f3n.","title":"Linked Clones"},{"location":"T2/#ventajas-y-desventajas","text":"La creaci\u00f3n de clones es casi instant\u00e1nea al no copiar el almacenamiento. Reduce espacio de dsico ocupado por cada nueva m\u00e1quina. Mejora la concurrencia de E/S a disco si el hipervisor implementa una cache de disco par alos bloques de los discos virtuales: * Reuso de las lecturas f\u00edsicas entre m\u00e1quinas virtuales. * Aumenta el hit-ratio de la cach\u00e9 de disco del hipervisor al acceder al mismo bloque en varias m\u00e1quinas. Si varios clones arrancan a la vez, el uso de disco no se multiplica por el n\u00famero de m\u00e1quinas virtuales. No se puede actualizar la plantilla ya que habr\u00eda que destruir los clones.","title":"Ventajas y Desventajas"},{"location":"T2/#uso-de-los-linked-clones","text":"Son muy \u00fatiles para escritorios virtuales. Puesto que existen numerosas instancias id\u00e9nticas a partir de una misma plantilla. Adem\u00e1s la vida de una m\u00e1quina virtual es breve (horas/d\u00edas). Los clones se destruyen cuando el usuario sale de la sesi\u00f3n. En cada nueva sesi\u00f3n se usa una m\u00e1quina virtual reci\u00e9n clonada. Para poder llevar esto a cabo se necesita una infraestructura de software (broker de MVs) que genere los clones bajo demanda.","title":"Uso de los linked-clones"},{"location":"T2/#virtualizacion-de-la-red","text":"Es necesario simular una o m\u00e1s interfaces de red (NIC) en cada m\u00e1quina virtual y una o m\u00e1s LANs virtuales (switches Ethernet) simulando el trasporte de los paquetes; bien entre m\u00e1quinas virtuales o entre la LAN real y las LANs virtuales con los NICs reales del sistema host.","title":"Virtualizaci\u00f3n de la red"},{"location":"T2/#nics-virtuales","text":"Cada NIC simula una interfaz de red con su propia MAC \u00fanica. Para cada NIC virtual el administrador especifica a qu\u00e9 LAN virtual se conecta. Se simula el interfaz de control (mediante registros de control y estado) de NICs populares para que el sistema operativo pueda usar drivers est\u00e1ndar. Algunos hipervisores simulan NICs virtuales optimizadas para rendimiento en una MV, pero requieren de drivers especiales.","title":"NICs virtuales"},{"location":"T2/#lans-virtuales-en-desktops","text":"El hipervisor se encarga de simular 1 o m\u00e1s LANs virtuales. Cada LAN virtual puede estar asociada a un NIC real del host de diversas formas: Bridged: el NIC funciona como un bridge Ethernet (nivel 2) entre la LAN virtual y la LAN externa. NAT: se interpone un router IP con NAT entre la LAN virtual y la LAN externa usando como direcci\u00f3n la IP del host real. Las MVs tienen visibilidad a nivel IP de la LAN externa con las limitaciones inherentes de la NAT. Host-Only: La LAN no est\u00e1 asociada a ning\u00fan NIC (se encuentra aislada del exterior). Se utiliza para comunicar MVs entre si.","title":"LANs Virtuales en desktops"},{"location":"T2/#lans-virtuales-en-servidores","text":"Se simulan uno o m\u00e1s switches virtuales Ethernet. Un vSwitch tiene asociados a su vez 0 o m\u00e1s NICs reales. Si tiene 0 se encuentra aislado del exterior. Si posee m\u00e1s de 1 se pueden usar pol\u00edticas de balanceo de carga o de fail-over. Cada NIC real aparenta un enlace Ethernet punto a punto entre el switch virtual y un switch externo. Dentro de cada vSwitch se definen 1 o m\u00e1s VLANs (grupos de puertos). Una MV puede tener 1 o m\u00e1s NICs virtuales conectadas a distintos grupos de puertos. A cada grupo de puertos se le asocia un tag de VLAN 802.1q. Los NICs reales multiplexan el enlace trabajando en modo trunk 802.1q (identificando la VLAN o grupos de cada paquete mediante el identificador o tag 802.1q en la cabecera del pquete). Los switches externos deben soportar tambi\u00e9n la multiplexaci\u00f3n IEEE802.1q en los puertos a los que est\u00e1n conectados los NICs reales del hipervisor.","title":"LANs virtuales en servidores"},{"location":"T2/#implementacion-de-las-lans","text":"El paso de paquetes Ethernet entre NICs de m\u00e1quinas virtuales conectadas al mismo switch virtual se hace mediante buffers de memoria del hipervisor. Esto permite que la velocidad de paso de datos sea muy elevada. Las comunicaciones con el switch exterior se hacen compartiendo el NIC exterior. Cada MV usa su propia MAC para emitir. La recepci\u00f3n se hace en modo promiscuo. Los paquetes recibidos se entregan a NIC con la MAC correspondiente.","title":"Implementaci\u00f3n de las LANs"},{"location":"T2/#avances-en-el-soporte-de-virtualizacion-de-las-cpus","text":"El soporte b\u00e1sico ayuda con la simulaci\u00f3n del comportamiento y registros de la CPU de la MV en modo pseudo-supervisor. La traducci\u00f3n de la MMU se puede hacer programando h\u00e1bilmente el hardware de paginaci\u00f3n, pero existen problemas de seguridad. Las CPUs actuales tambi\u00e9n aportan un modo virtual para que el hardware de paginaci\u00f3n que no posee permisos pueda acceder fuera de la memoria de la MV. El acceso a los dispotivios PCI se hace interceptando las instrucciones de acceso a los registros de control (IN/OUT). Algunas CPUs recientes incorporan dispositivos PCI virtuales que pueden ser simulaci\u00f3n por software o bien una acceso controlado a un dispositivo PCI verdadero.","title":"Avances en el soporte de virtualizaci\u00f3n de las CPUs"},{"location":"T3/","text":"Virtualizaci\u00f3n en el x86 Realizado con la mentalidad de aprovechar al m\u00e1ximo los transistores. Por ello, es muy irregular. La arquitectura x86 fue predominante desde los a\u00f1os 90. A d\u00eda de hoy sigue si\u00e9ndolo, excepto en dispositivos m\u00f3viles o plataformas donde el bajo consumo es importante. A pesar de que la virtualizaci\u00f3n exist\u00eda implementada (con m\u00e1quinas como la IBM VM/370), no fue hasta finales de los 90 que compa\u00f1ias como VMware comienzan a virtualizar las plataformas basadas en x86. Adem\u00e1s, comienzan a existir equipos baratos que pod\u00edan emular servidores de m\u00e1s coste; lo cual provoca un gran inter\u00e9s en la virtualizaci\u00f3n. Modos de ejecuci\u00f3n IA-32 Existe un modo de arranque denominado modo real . En este modo se ejecuta la rutina de arranque del fabricante. En este modo trabajamos en 16 bits. Posteriormente, pasamos a un modo protegido . En este tenemos un funcionamiento normal del procesador. Es aqu\u00ed cuando se comienza a ejecutar el sistema operativo. En este modo, intel introdujo 4 niveles de privilegio . Su finalidad fue facilitar la vida a los desarrolladores de drivers, proporcionando ciertos privilegios sin llegar a tener modo kernel. Adem\u00e1s, podemos encontrar un modo virtual , que fue usado en su d\u00eda por microsoft para el sitema de ventanas de ms-dos. Este modo a\u00fan se ejecutaba en 16 bits, por tanto exist\u00eda virtualizaci\u00f3n para poder llevar esto a cabo. Virtualizaci\u00f3n estricta En la estructura x86, existen instrucciones \"malas\", pues ciertas instrucciones se comportan de forma distinta seg\u00fan si se encuentra en modo kernel o modo usuario . Esto provoca que no sea estrictamente virtualizable (segun Popek y Goldberg). Ser\u00eda posible implementar un hipervisor con el modo \"traza\" del CPU. Esto provoca una interrupci\u00f3n entre cada instrucci\u00f3n. Lo cual tiene como consecuencia un gran golpe en rendimiento. Soporte HW: Intel VT-x Para solventar los problemas se introdujo un nuevo modo de operaci\u00f3n, que se implement\u00f3 con el uso de un solo bit (principalmente, existen m\u00e1s cambios). Diagrama (m\u00e1s arriba \u2192 menos privilegio): ring3 | ring2 | ring1 | ring0 \u2192 Non-root (nuevo modo) ring3 | ring2 | ring1 | ring0 \u2192 root mode (user) (kernel) Modo root: Todas las instrucciones en este modo no son diferentes a las de la arquitectura tradicional. El software antiguo (legacy) deber\u00eda ejecutarse correctamente en este modo. El hipervisor debe correr en modo privilegiado para tener control de todos los recursos. Modo non-root: Pensado para las m\u00e1quinas virtuales. Se redise\u00f1an todas las instrucciones cr\u00edticas (sensitive). Las instrucciones cr\u00edticas provocan un trap que pasa la CPU a modo root. El sistema operativo guest debe ejecutarse en modo non-root pudiendo ser emulado completamente con el concepto \"trap and emulate\" . La idea es que el sistema operativo host se ejecute en el modo root con kernel 0 con los programas de usuario en el anillo 3. Los del sistema operativo guest en el nivel non-root, con su kernel en el respectivo ring 0 y sus programas de usuario en su ring 3. Si ahora se provocara una interrupci\u00f3n en el nivel non-root(vm) saltar\u00eda una interrupci\u00f3n con su tabla shadow. La m\u00e1quina virtual \"vive\" en sus anillos y es solamente cuando surge una interrupci\u00f3n que salta de su modo del hipervisor. De este modo, la m\u00e1quina virtual no puede distinguir que se encuentra en una m\u00e1quina virtual. El ring -1 es una met\u00e1fora. MV (context) switch Realmente realizar un cambio a una MV es muy parecido a un cambio de contexto. Es necesario realizar cambios en las instrucciones, por ejemplo introducir instrucciones para entrar/salir de los modos Non-root/Root. Si una m\u00e1quina realizara un Halt, se deber\u00e1 transformar a un exit, pues esa MV queda inutil. Formalmente se conocen varias instrucciones: VMXON/VMXOFF: Usadas para encender o apagar el modo root de la CPU. VM Entry: usada al VMLAUNCH/VMRESUME, cambia de modo root de la cpu a non-root mode. VM Exit: Usada por interrupts de hardware or ejecuci\u00f3n sensitiva. Tambi\u00e9n para pasar de modo non-root a modo root. VT-x: System State Management Intel posee ciertos manejadores de tareas. A nivel de modo Non-root, proporciona estructuras de datos a nivel hardware en la CPU. Se proporcionan, obviamente, tambi\u00e9n instrucciones para manejar estas estructuras. Esto Intel lo llam\u00f3 VMCS (Virtual Machine Control Structure) , que nos permite obtener informaci\u00f3n de: State Area: estado del sistema Host/Guest OS cuando se produce VM-entry/exit. Control Area: controla el comportamiento de las instrucciones en modo non-root; as\u00ed como controlar el proceso de VM-Entry y VM-Exit. Exit Information: Proporciona informaci\u00f3n sobre la razon de la VM-Exit y m\u00e1s informaci\u00f3n de hardware. Virtualizadores para plataformas x86 Existen diversas soluciones. Las m\u00e1s famosas son: VMWare: Con hipervisores tipo 2 (vmware workstation) y 1 (ESXi). KVM: kernel-based virtual machine. Open source con linux como hipervisor. Formado por m\u00f3dulos de kernel. Qemu: quick emulator. Permite emular gran cantidad de plataformas y formatos. Oracle: productos como virtualbox (es un hosted hypervisor). Microsoft: Hiper-V, orientado a servidores con un hipervisor en bare metal. O con virtual PC (hipervisor tipo 2). Xen: hipervisor baremetal con m\u00e1quina privilegiada. Containers Se basa en MVs ligeras (que permite arranque r\u00e1pido, clonado eficiente y una m\u00ednima instalaci\u00f3n). Se busca una aproximaci\u00f3n lo m\u00e1s pr\u00f3ximo posible a los 3 principios de Popek y Goldberg. Esto permite una estandarizaci\u00f3n y portabilidad. Es virtualizaci\u00f3n a nivel de SO, pero no es una MV. Utiliza el kernel del host. No puede arrancar un kernel propio (o diferente). No posee sus drivers. No necesita algunos daemons o servicios ni un proceso PID 1 (init). Un container es un conjunto de procesos visibles al host pero con cierto aislamiento entre ellos. En la comunidad se dice que un container es un chroot con esteroides. Se basa en sandboxing con chroot, el mapeo de identificadores con namespaces y el control de recursos con cgroups. Los container se han hecho muy populares en los \u00faltimos a\u00f1os y han surgido incluso softwares para la gesti\u00f3n y control del ciclo de vida de ellos en grandes infraestructuras.","title":"Virtualizaci\u00f3n en el x86"},{"location":"T3/#virtualizacion-en-el-x86","text":"Realizado con la mentalidad de aprovechar al m\u00e1ximo los transistores. Por ello, es muy irregular. La arquitectura x86 fue predominante desde los a\u00f1os 90. A d\u00eda de hoy sigue si\u00e9ndolo, excepto en dispositivos m\u00f3viles o plataformas donde el bajo consumo es importante. A pesar de que la virtualizaci\u00f3n exist\u00eda implementada (con m\u00e1quinas como la IBM VM/370), no fue hasta finales de los 90 que compa\u00f1ias como VMware comienzan a virtualizar las plataformas basadas en x86. Adem\u00e1s, comienzan a existir equipos baratos que pod\u00edan emular servidores de m\u00e1s coste; lo cual provoca un gran inter\u00e9s en la virtualizaci\u00f3n.","title":"Virtualizaci\u00f3n en el x86"},{"location":"T3/#modos-de-ejecucion-ia-32","text":"Existe un modo de arranque denominado modo real . En este modo se ejecuta la rutina de arranque del fabricante. En este modo trabajamos en 16 bits. Posteriormente, pasamos a un modo protegido . En este tenemos un funcionamiento normal del procesador. Es aqu\u00ed cuando se comienza a ejecutar el sistema operativo. En este modo, intel introdujo 4 niveles de privilegio . Su finalidad fue facilitar la vida a los desarrolladores de drivers, proporcionando ciertos privilegios sin llegar a tener modo kernel. Adem\u00e1s, podemos encontrar un modo virtual , que fue usado en su d\u00eda por microsoft para el sitema de ventanas de ms-dos. Este modo a\u00fan se ejecutaba en 16 bits, por tanto exist\u00eda virtualizaci\u00f3n para poder llevar esto a cabo.","title":"Modos de ejecuci\u00f3n IA-32"},{"location":"T3/#virtualizacion-estricta","text":"En la estructura x86, existen instrucciones \"malas\", pues ciertas instrucciones se comportan de forma distinta seg\u00fan si se encuentra en modo kernel o modo usuario . Esto provoca que no sea estrictamente virtualizable (segun Popek y Goldberg). Ser\u00eda posible implementar un hipervisor con el modo \"traza\" del CPU. Esto provoca una interrupci\u00f3n entre cada instrucci\u00f3n. Lo cual tiene como consecuencia un gran golpe en rendimiento.","title":"Virtualizaci\u00f3n estricta"},{"location":"T3/#soporte-hw-intel-vt-x","text":"Para solventar los problemas se introdujo un nuevo modo de operaci\u00f3n, que se implement\u00f3 con el uso de un solo bit (principalmente, existen m\u00e1s cambios). Diagrama (m\u00e1s arriba \u2192 menos privilegio): ring3 | ring2 | ring1 | ring0 \u2192 Non-root (nuevo modo) ring3 | ring2 | ring1 | ring0 \u2192 root mode (user) (kernel) Modo root: Todas las instrucciones en este modo no son diferentes a las de la arquitectura tradicional. El software antiguo (legacy) deber\u00eda ejecutarse correctamente en este modo. El hipervisor debe correr en modo privilegiado para tener control de todos los recursos. Modo non-root: Pensado para las m\u00e1quinas virtuales. Se redise\u00f1an todas las instrucciones cr\u00edticas (sensitive). Las instrucciones cr\u00edticas provocan un trap que pasa la CPU a modo root. El sistema operativo guest debe ejecutarse en modo non-root pudiendo ser emulado completamente con el concepto \"trap and emulate\" . La idea es que el sistema operativo host se ejecute en el modo root con kernel 0 con los programas de usuario en el anillo 3. Los del sistema operativo guest en el nivel non-root, con su kernel en el respectivo ring 0 y sus programas de usuario en su ring 3. Si ahora se provocara una interrupci\u00f3n en el nivel non-root(vm) saltar\u00eda una interrupci\u00f3n con su tabla shadow. La m\u00e1quina virtual \"vive\" en sus anillos y es solamente cuando surge una interrupci\u00f3n que salta de su modo del hipervisor. De este modo, la m\u00e1quina virtual no puede distinguir que se encuentra en una m\u00e1quina virtual. El ring -1 es una met\u00e1fora.","title":"Soporte HW: Intel VT-x"},{"location":"T3/#mv-context-switch","text":"Realmente realizar un cambio a una MV es muy parecido a un cambio de contexto. Es necesario realizar cambios en las instrucciones, por ejemplo introducir instrucciones para entrar/salir de los modos Non-root/Root. Si una m\u00e1quina realizara un Halt, se deber\u00e1 transformar a un exit, pues esa MV queda inutil. Formalmente se conocen varias instrucciones: VMXON/VMXOFF: Usadas para encender o apagar el modo root de la CPU. VM Entry: usada al VMLAUNCH/VMRESUME, cambia de modo root de la cpu a non-root mode. VM Exit: Usada por interrupts de hardware or ejecuci\u00f3n sensitiva. Tambi\u00e9n para pasar de modo non-root a modo root.","title":"MV (context) switch"},{"location":"T3/#vt-x-system-state-management","text":"Intel posee ciertos manejadores de tareas. A nivel de modo Non-root, proporciona estructuras de datos a nivel hardware en la CPU. Se proporcionan, obviamente, tambi\u00e9n instrucciones para manejar estas estructuras. Esto Intel lo llam\u00f3 VMCS (Virtual Machine Control Structure) , que nos permite obtener informaci\u00f3n de: State Area: estado del sistema Host/Guest OS cuando se produce VM-entry/exit. Control Area: controla el comportamiento de las instrucciones en modo non-root; as\u00ed como controlar el proceso de VM-Entry y VM-Exit. Exit Information: Proporciona informaci\u00f3n sobre la razon de la VM-Exit y m\u00e1s informaci\u00f3n de hardware.","title":"VT-x: System State Management"},{"location":"T3/#virtualizadores-para-plataformas-x86","text":"Existen diversas soluciones. Las m\u00e1s famosas son: VMWare: Con hipervisores tipo 2 (vmware workstation) y 1 (ESXi). KVM: kernel-based virtual machine. Open source con linux como hipervisor. Formado por m\u00f3dulos de kernel. Qemu: quick emulator. Permite emular gran cantidad de plataformas y formatos. Oracle: productos como virtualbox (es un hosted hypervisor). Microsoft: Hiper-V, orientado a servidores con un hipervisor en bare metal. O con virtual PC (hipervisor tipo 2). Xen: hipervisor baremetal con m\u00e1quina privilegiada.","title":"Virtualizadores para plataformas x86"},{"location":"T3/#containers","text":"Se basa en MVs ligeras (que permite arranque r\u00e1pido, clonado eficiente y una m\u00ednima instalaci\u00f3n). Se busca una aproximaci\u00f3n lo m\u00e1s pr\u00f3ximo posible a los 3 principios de Popek y Goldberg. Esto permite una estandarizaci\u00f3n y portabilidad. Es virtualizaci\u00f3n a nivel de SO, pero no es una MV. Utiliza el kernel del host. No puede arrancar un kernel propio (o diferente). No posee sus drivers. No necesita algunos daemons o servicios ni un proceso PID 1 (init). Un container es un conjunto de procesos visibles al host pero con cierto aislamiento entre ellos. En la comunidad se dice que un container es un chroot con esteroides. Se basa en sandboxing con chroot, el mapeo de identificadores con namespaces y el control de recursos con cgroups. Los container se han hecho muy populares en los \u00faltimos a\u00f1os y han surgido incluso softwares para la gesti\u00f3n y control del ciclo de vida de ellos en grandes infraestructuras.","title":"Containers"}]}